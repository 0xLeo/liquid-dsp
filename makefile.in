# 
# Makefile for liquid SDR libraries
#

# paths
srcdir = @srcdir@
prefix = @prefix@
exec_prefix = @exec_prefix@
VPATH = @srcdir@
include_dirs	:= . include
vpath %.h $(include_dirs)
modulesdir = src

# programs
CC = @CC@
MV	:= mv -f
RM	:= rm -f
SED	:= sed
AR	:= ar
RANLIB	:= ranlib

# flags
INCLUDE_CFLAGS	= $(addprefix -I ,$(include_dirs))
CONFIG_CFLAGS	= @ARCH_OPTION@ @PROFILE_OPTION@ @DEBUG_OPTION@
# -g : debugging info
CFLAGS		+= $(INCLUDE_CFLAGS) -g -O2 -Wall $(CONFIG_CFLAGS)
LDFLAGS		+= -lm
ARFLAGS		= r

# Liquid modules
#
# Each processing library is held in a module containing
# its own makefile 'module.mk' included by this top-level
# makefile.
#
# Each module's 'module.mk' contains the following:
#    local_dir     : local directory, e.g. $(modulesdir)/mymodule
#    local_lib     : local library, e.g. libmymodule.a
#    local_s_files : source files e.g. '.c'
#    local_h_files : internal header files
#    local_t_files : autotest script headers
#    local_b_files : benchmark script headers
modules		:=	\
	agc		\
	buffer		\
	channel		\
	dotprod		\
	estimation	\
	fec		\
	fft		\
	filter		\
	interleaver	\
	framing		\
	math		\
	matrix		\
	modem 		\
	nco 		\
	random		\
	sequence	\
	utility
#	ann
#	optim

# Target collection
#
# Information about targets for each module is collected
# in these variables
programs		:=
sources			:=
libraries		:=
extra_clean		:=
autotest_headers	:=
benchmark_headers	:=

objects		= $(patsubst %.c,%.o,$(sources))
dependencies	= $(patsubst %.c,%.d,$(sources))


all:


# Include module.mk
#
# Generate list of module.mk includes from $(modules), e.g.
#    include $(modulesdir)/utility/module.mk
#    include $(modulesdir)/modem/module.mk
#
include $(patsubst %,$(modulesdir)/%/module.mk,$(modules))


# Dependencies
#
# Use compiler's -M flags (and equivalent) to parse source files
# and create a list of dependencies.  Each list is stored in a
# .d file and included, below.
#
%.d: %.c
	$(CC) $(CFLAGS) -MM -MG $< | $(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,' > $@
include $(dependencies)

# Shared library
SHARED_LIB	= @SH_LIB@
.PHONY: all
all: libliquid.a $(SHARED_LIB)

.PHONY: libraries
libraries: $(libraries)

# Liquid library definition
# TODO: link from module libraries, not object files (for compactness)
libliquid.a: $(objects)
	$(AR) $(ARFLAGS) $@ $^
	$(RANLIB) $@

# darwin
#
# gcc -dynamiclib -install_name libliquid.dylib -o libliquid.dylib libmodem.a libutility.a 
libliquid.dylib: $(objects)
	$(CC) -dynamiclib -install_name $@ -o $@ $^

# linux, et al
libliquid.so: $(libraries)
	$(CC) -shared -Xlinker -soname=$@ -o $@ -Wl,-whole-archive $^ -Wl,-no-whole-archive

# TARGET: install
#
# Installs the libraries and header files in the host system
install:
	@echo "installing..."
	mkdir -p $(exec_prefix)/lib
	install -m 644 -p $(SHARED_LIB) libliquid.a $(exec_prefix)/lib
	mkdir -p $(prefix)/include
	mkdir -p $(prefix)/include/liquid
	install -m 644 -p include/liquid.h $(prefix)/include/liquid

# Autotests
#
# Autotests are used to check the validity and accuracy of the
# DSP libraries.
.PHONY: autotest
autotest_prog	= xautotest

# run the autotest generator script to create autotest_include.h
autotest_include.h: $(autotest_headers)
	python autotest/autotest_gen.py $(autotest_headers)

# compile the autotest program without linking
$(autotest_prog).o: autotest_include.h autotest/autotest.c
	$(CC) $(CFLAGS) autotest/autotest.c -c -o $@

# link the autotest program with the objects
# NOTE: linked libraries must come _after_ the target program
$(autotest_prog): $(autotest_prog).o libliquid.a
	$(CC) $^ $(LDFLAGS) -o $@

# run the autotest program
check: $(autotest_prog)
	./$(autotest_prog) -v

# clean the generated files
check-clean:
	$(RM) autotest_include.h $(autotest_prog).o $(autotest_prog)



# Benchmarks
#
# Benchmarks measure the relative speed of the DSP algorithms running
# on the target platform.
.PHONY: bench
bench_prog	= benchmark
BENCH_CFLAGS	= -Wall $(INCLUDE_CFLAGS) $(CONFIG_CFLAGS)
BENCH_LDFLAGS	= $(LDFLAGS) -pthread

# run the benchmark generator scrip to create benchmark_include.h
benchmark_include.h: $(benchmark_headers)
	python bench/benchmarkgen.py $(benchmark_headers)

# compile the benchmark program without linking
$(bench_prog).o: benchmark_include.h bench/bench.c
	$(CC) $(BENCH_CFLAGS) -c bench/bench.c -o $(bench_prog).o

# link the benchmark program with the library objects
# NOTE: linked libraries must come _after_ the target program
$(bench_prog): $(bench_prog).o libliquid.a
	$(CC) $^ $(BENCH_LDFLAGS) -o $(bench_prog)

# run the benchmark program
bench: $(bench_prog)
	./$(bench_prog)

# clean up the generated files
bench-clean:
	$(RM) benchmark_include.h $(bench_prog).o $(bench_prog)


# Examples
.PHONY: examples
include examples/examples.mk
example_objs	= $(patsubst %.c,%.o,$(example_src))
example_deps	= $(patsubst %.c,%.d,$(example_src))
example_progs	= $(patsubst %.c,%,  $(example_src))
examples: $(example_progs)
EXAMPLES_LDFLAGS = $(LDFLAGS) -pthread

# Dependencies
#$(example_deps): $(example_src)
#	$(CC) $(CFLAGS) -MM -MG $< | $(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,' > $@
#include $(example_deps)

$(example_objs): %.o : %.c
	$(CC) $(CFLAGS) $< -c -o $@

# NOTE: linked libraries must come _after_ the target program
$(example_progs): % : %.o libliquid.a
	$(CC) $(CFLAGS) $< $(EXAMPLES_LDFLAGS) libliquid.a -o $@

# clean examples
examples-clean:
	$(RM) $(example_objs)
	$(RM) $(example_progs)
	$(RM) examples/*.m

# Clean
.PHONY: clean
clean: check-clean bench-clean examples-clean
	$(RM) $(objects)
	$(RM) $(programs)
	$(RM) $(libraries)
	$(RM) $(dependencies)
	$(RM) $(extra_clean)
	$(RM) libliquid.a
	$(RM) $(SHARED_LIB)


