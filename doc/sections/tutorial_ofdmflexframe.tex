% 
% TUTORIAL : ofdmflexframe
%

\newpage
\section{Tutorial: OFDM Framing}
\label{tutorial:ofdmflexframe}

In the previous tutorials we have created only the basic building blocks
for wireless communication.
We have also used the basic {\tt framegen64} and {\tt framesync64}
objects to transmit and receive simple framing data.
This tutorial extends...


%
% SUBSECTION : problem statement
%
\subsection{Problem Statement}
\label{tutorial:ofdmflexframe:problem}
% talking points:
%   * what is OFDM (briefly)
%   * the benefits of OFDM (briefly)
%   * current standards using OFDM



%
% SUBSECTION : 
%
\subsection{Setting up the Environment}
\label{tutorial:ofdmflexframe:environment}

As with the other tutorials I assume that you are using {\tt gcc} to
compile your programs and link to appripriate libraries.
Create a new file {\tt ofdmflexframe.c} and include the headers
{\tt stdio.h},
{\tt stdlib.h},
{\tt math.h},
{\tt complex.h}, and
{\tt liquid/liquid.h}.
Add the {\tt int main()} definition so that your program looks like
this:
%
\input{tutorials/ofdmflexframe_init_tutorial.c.tex}
%
Compile and link the program using {\tt gcc}:
%
\begin{Verbatim}[fontsize=\small]
    $ gcc -Wall -o ofdmflexframe -lm -lc -lliquid ofdmflexframe.c
\end{Verbatim}
%
The flag ``{\tt -Wall}'' tells the compiler to print all warnings
(unused and uninitialized variables, etc.),
``{\tt -o ofdmflexframe}'' specifies the name of the output program is
``{\tt ofdmflexframe}'', and
``{\tt -lm -lc -lliquid}'' tells the linker to link the binary against
the math, standard C, and \liquid\ DSP libraries, respectively.
Notice that the above command invokes both the compiler and the linker
collectively.
%While it is usually preferred to build an intermediate object...
%
If the compiler did not give any errors, the output executable
{\tt ofdmflexframe} is created which can be run as
%
\begin{Verbatim}[fontsize=\small]
    $ ./ofdmflexframe
\end{Verbatim}
%
and should simply print ``{\tt done.}'' to the screen.
You are now ready to add functionality to your program.



%
% SUBSECTION : framing structure
%
\subsection{OFDM Framing Structure}
\label{tutorial:ofdmflexframe:structure}
%
The OFDM framing stucture is described briefly here
(for a more detailed description, see
Section~\ref{module:framing:ofdmflexframe}).
The {\tt ofdmflexframe} generator and synchronizer objects
together realize a simple framing structure
for loading data onto a reconfigurable OFDM physical layer.
The generator encapsulates a xxx-byte user-defined header
and a variable-length buffer of uncoded payload data
and fully encodes a frame of OFDM symbols ready for transmission.
The user may define many physical-layer parameters of the transmission,
including
  the number of subcarriers and their allocation (null/pilot/data),
  cyclic prefix length,
  forward error-correction coding,
  modulation scheme,
  and others.
The synchronizer...

%
% SUBSECTION : frame generator
%
\subsection{Creating the Frame Generator}
\label{tutorial:ofdmflexframe:framegen}
%
The {\tt ofdmflexframegen} object can be generated with the
{\tt ofdmflexframegen\_create(M,c,p,props)} method which accepts four arguments:
%
\begin{itemize}
\item[$M$] is an {\tt unsigned int} representing the total number of
    subcarriers
\item[$c$] is an {\tt unsigned int} representing the length of the
    cyclic prefix
\item[$\vec{p}$] is an $M$-element array of {\tt unsigned char} which
    gives the subcarrier allocation (e.g. which subcarriers
    are nulled/disabled, which are pilots, and which carry data).
    Setting to {\tt NULL} tells the {\tt ofdmflexframegen} object to use
    the default subcarrier allocation
\item[{\tt props}] is a special structure called
    {\tt ofdmflexframegenprops\_s}
    which gives some basic properties including
    the length of the payload ({\tt payload\_len}),
    the forward error-correction scheme(s) to use ({\tt fec0},
    {\tt fec1}),
    and the modulation scheme ({\tt mod\_scheme}) and depth
    ({\tt mod\_depth}).
    The properties object can be initialized to its default by using
    {\tt ofdmflexframegenprops\_init\_default()}.
\end{itemize}
%
To begin, create a frame generator having 64 subcarriers with cyclic
prefix of 16 samples, the default subcarrier allocation, and
a payload of 120 bytes (but otherwise default properties) as
%
\begin{Verbatim}[fontsize=\small]
    ofdmflexframegenprops_s fgprops;                // create properties object
    ofdmflexframegenprops_init_default(&fgprops);   // initialize to default
    fgprops.payload_len = 120;                      // set payload length

    // create frame generator and print
    ofdmflexframegen fg = ofdmflexframegen_create(64, 16, NULL, &fgprops);
    ofdmflexframegen_print(fg);
\end{Verbatim}
%
As with all structures in \liquid\ you will need to invoke the
corresponding {\tt destroy()} method when you are finished with the
object.

Now allocate memory for the header (8 bytes) and payload (120 bytes)
data arrays.
Raw ``message'' data are stored as arrays of type {\tt unsigned char} in
\liquid.
%
\begin{Verbatim}[fontsize=\small]
    unsigned char header[12];
    unsigned char payload[120];
\end{Verbatim}
%
Initialize the header and payload arrays with whatever values you wish.
%
Finally you will need to create a buffer for storing the frame samples.
Unlike the {\tt framegen64} object in the previous tutorial which
generates the entire frame at once,
the {\tt ofdmflexframegen} object generates each symbol independently.
%This reduces the amount of memory required and...
For this framing structure you will need to allocate $M+c$ samples of
type {\tt float complex} (for this example $M+c = 64+16 = 80$), viz.
%
\begin{Verbatim}[fontsize=\small]
    float complex buffer[80];
\end{Verbatim}

Generating the frame consists of two steps: assemble and write.
The {\tt ofdmflexframegen\_assemble(fg,header,payload)} method accepts
the frame generator object as well as the header and payload arrays we
initialized earlier.
Internally, the object encodes and modulates the frame, but does not
write the OFDM symbols yet.
To write the OFDM time-series symbols, invoke the
{\tt ofdmflexframegen\_writesymbol(fg,buffer,*num\_written)} method.
This method accepts three arguments:
  the frame generator object,
  the output buffer we created earlier,
  and the pointer to an integer to indicate the number of samples that
  have been written to the buffer.
The last argument is necessary because not all of the symbols in the
frame are the same size (the first several symbols in the preamble do
not have a cycic prefix).
Invoking the {\tt ofdmflexframegen\_writesymbol()} method repeatedly
generates each symbol of the frame
and returns a flag indicating if the last symbol in the frame has been
written.

Add the instructions to assemble and write a frame one symbol at a time
to your source code:
%
\begin{Verbatim}[fontsize=\small]
    // assemble the frame
    ofdmflexframegen_assemble(fg, header, payload);

    // generate the frame one OFDM symbol at a time
    int last_symbol=0;          // flag indicating if this is the last symbol
    unsigned int num_written;   // number of samples written to the buffer
    while (!last_symbol) {
        // write samples to the buffer
        last_symbol = ofdmflexframegen_writesymbol(fg, buffer, &num_written);
    }
\end{Verbatim}
%
That's it!
This completely assembles the frame complete with error-correction
coding, pilot subcarriers, and the preamble necessary for
synchronization.
You may generate another frame simply by
  initializing the data in your {\tt header} and {\tt payload} arrays,
  assembling the frame,
  and then writing the symbols to the buffer.
Keep in mind, however, that the buffer is overwritten each time you
invoke {\tt ofdmflexframegen\_writesymbol()},
so you will need to do something with the data with each iteration of
the loop.
%
Your program should now look similar to this:
%
\input{tutorials/ofdmflexframe_basic_tutorial.c.tex}
%
Running the program should produce an output similar to this:
%
\begin{Verbatim}[fontsize=\small]
ofdmflexframegen:
    num subcarriers     :   64
      * NULL            :   12
      * pilot           :   6
      * data            :   46
    cyclic prefix len   :   16
    properties:
      * mod scheme      :   quaternary phase-shift keying (2 b/s)
      * fec (inner)     :   none
      * fec (outer)     :   none
      * CRC scheme      :   CRC (16-bit)
    payload:
      * decoded bytes   :   120
      * encoded bytes   :   122
      * modulated syms  :   488
    total OFDM symbols  :   18
      * S0 symbols      :   3 @ 64
      * S1 symbols      :   1 @ 80
      * header symbols  :   3 @ 80
      * payload symbols :   11 @ 80
    spectral efficiency :   0.6897 b/s/Hz
done.
\end{Verbatim}
%
Notice that the {\tt ofdmflexframegen\_print()} method gives a lot of
information, including
the number of null, pilot, and data subcarriers,
the number of modulated symbols,
the number of OFDM symbols,
and the resulting spectral efficiency.

%
% SUBSECTION : frame synchronizer
%
\subsection{Creating the Frame Synchronizer}
\label{tutorial:ofdmflexframe:framesync}
The OFDM frame synchronizer...

%
% SUBSECTION : 
%
\subsection{Putting it All Together}
\label{tutorial:ofdmflexframe:xxx}

%
% SUBSECTION : 
%
\subsection{Final Program}
\label{tutorial:ofdmflexframe:completed}

%
\input{tutorials/ofdmflexframe_tutorial.c.tex}
%
Running the program should produce an output similar to this:
%
\begin{Verbatim}[fontsize=\small]
ofdmflexframegen:
    num subcarriers     :   64
      * NULL            :   12
      * pilot           :   6
      * data            :   46
    cyclic prefix len   :   16
    properties:
      * mod scheme      :   quaternary phase-shift keying (2 b/s)
      * fec (inner)     :   none
      * fec (outer)     :   Hamming(12,8)
      * CRC scheme      :   CRC (32-bit)
    payload:
      * decoded bytes   :   120
      * encoded bytes   :   186
      * modulated syms  :   744
    total OFDM symbols  :   24
      * S0 symbols      :   3 @ 64
      * S1 symbols      :   1 @ 80
      * header symbols  :   3 @ 80
      * payload symbols :   17 @ 80
    spectral efficiency :   0.5128 b/s/Hz
***** callback invoked!
  header (valid)
  payload (valid)
done.
\end{Verbatim}
%
