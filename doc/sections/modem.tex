% 
% MODULE : modem
%

\newpage
\section{modem}
\label{module:modem}
The modem module implements a set of (mod)ulation/(dem)odulation schemes
for encoding information into signals.
%For the analog modems, samples are modulated according to...
For the digital modems, data bits are encoded into symbols representing
carrier frequency, phase, amplitude, etc.
This section gives a brief overview of modulation schemes available in
\liquid, and provides a brief description of the interfaces.


%
% ANALOG MODEMS
%

\subsection{Analog modulation schemes}
\label{module:modem:analog}

\subsubsection{{\tt freqmodem} (analog FM)}
\label{module:modem:analog:freqmodem}
The {\tt freqmodem} object implements an analog frequency modulation
(FM) modulator and demodulator.
Given an input message signal $-1 \le m(t) \le 1$, the transmitted
signal is
%
\begin{equation}
\label{eqn:modem:freqmodem_tx}
    s(t) =  \exp\left\{
                j 2 \pi k f_c
                \int_{0}^{t}{
                    m(\tau)d\tau
                }
            \right\}
\end{equation}
%
where $f_c$ is the carrier frequency, and $k$ is the modulation index.
The modulation index governs the relative bandwidth of the signal.
Two options for demodulation are possible:
observing the instantaneous frequency on the output of a phase-locked
loop,
or computing the instantaneous frequency using the delay-conjugate
method.
%Its digital equivalent is
%\[
%    s(nT_s) =   \exp\left\{
%                    j 2 \pi k f_c
%                    \sum_{k=0}^{n}{
%                        m(kT_s)
%                    }
%                \right\}
%\]
%
An example of the {\tt freqmodem} interface is listed below.
%
\input{listings/freqmodem.example.c.tex}
%
A more detailed example can be found in
{\tt examples/freqmodem\_example.c}
located under the main \liquid\ project source directory.
Listed below is the full interface to the {\tt freqmodem} object for
analog frequency modulation/demodulation.
%
\begin{description}
\item[{\tt freqmodem\_create(k,fc,type)}]
    creates and returns an {\tt freqmodem} object with a modulation
    index $k$, a carrier frequency $-0.5 < f_c < 0.5$, and a
    demodulation type defined by {\tt type}.
    The demodulation type can either be
    {\tt LIQUID\_MODEM\_FM\_PLL} which uses a phased-locked loop or
    {\tt LIQUID\_MODEM\_FM\_DELAY\_CONJ} which uses the delay conjugate
    method.
\item[{\tt freqmodem\_destroy(q)}]
    destroys an {\tt freqmodem} object, freeing all internally-allocated
    memory.
\item[{\tt freqmodem\_reset(q)}]
    resets the state of the {\tt freqmodem} object.
\item[{\tt freqmodem\_print(q)}]
    prints the internal state of the {\tt freqmodem} object.
\item[{\tt freqmodem\_modulate(q,x,*y)}]
    modulates the input sample $x$ storing the output to $y$.
\item[{\tt freqmodem\_demodulate(q,y,*x)}]
    demodulates the input sample $y$ storing the output to $x$.
\end{description}

% TODO : clean up this section!
\subsubsection{{\tt ampmodem} (analog AM)}
\label{module:modem:analog:ampmodem}
The {\tt ampmodem} object implements an analog amplitude modulation (AM)
modulator/demodulator pair.
Two basic transmission schemes are available:
single side-band (SSB), and
double side-band (DSB).

For an input message signal $-1 \le m(t) \le 1$, the double side-band
transmitted signal is
%
\begin{equation}
\label{eqn:modem:ampmodem:dsb_tx}
    s_{DSB}(t) = 
    \begin{cases}
        km(t)e^{j 2 \pi f_c t}   &   \text{suppressed carrier} \\
        \frac{1}{2}\Bigl(1+m(t)\Bigr)e^{j 2 \pi f_c t}   &   \text{unsuppressed carrier}
    \end{cases}
\end{equation}
%
where $f_c$ is the carrier frequency, and $k$ is the modulation index.

For DSB, the receiver uses a phase-locked loop for carrier frequency and
phase tracking.
For SSB, the receiver can either use a peak detector, or phase-locked loop
({\it not yet implemented}).

Single side-band:
\[
    s_1(t) = \frac{1}{2}\Bigl(1+k m(t)\Bigr)e^{j 2 \pi f_c t}
\]
where $-1 \le m(t) \le 1$ is the message signal, $f_c$ is the carrier frequency,
and $k$ is the modulation index.

An example of the {\tt freqmodem} interface is listed below.
%
\input{listings/ampmodem.example.c.tex}
%
A more detailed example can be found in
{\tt examples/ampmodem\_example.c}
located under the main \liquid\ project source directory.
Listed below is the full interface to the {\tt ampmodem} object for
analog frequency modulation/demodulation.
%
\begin{description}
\item[{\tt ampmodem\_create(k,type,suppressed\_carrier)}]
    creates and returns an {\tt ampmodem} object with a modulation
    index $k$,
    a modulation scheme defined by {\tt type},
    and a binary flag specifying whether the carrier should be
    suppressed.
    The modulation type can either be
    {\tt LIQUID\_MODEM\_AM\_DSB} (double side-band),
    {\tt LIQUID\_MODEM\_FM\_USB} (single upper side-band), or
    {\tt LIQUID\_MODEM\_FM\_LSB} (single lower side-band).
    method.
\item[{\tt ampmodem\_destroy(q)}]
    destroys an {\tt ampmodem} object, freeing all internally-allocated
    memory.
\item[{\tt ampmodem\_reset(q)}]
    resets the state of the {\tt ampmodem} object.
\item[{\tt ampmodem\_print(q)}]
    prints the internal state of the {\tt ampmodem} object.
\item[{\tt ampmodem\_modulate(q,x,*y)}]
    modulates the input sample $x$ storing the output to $y$.
\item[{\tt ampmodem\_demodulate(q,y,*x)}]
    demodulates the input sample $y$ storing the output to $x$.
\end{description}


%\subsection{Continuous phase digital modulation schemes}
%fsk, msk, etc. [NOTE: not yet implemented]



%
% DIGITAL MODEMS
%

\subsection{Linear digital modulation schemes}
\label{module:modem:digital}
The {\tt modem} object realizes the linear digital modulation library in which
the information from a symbol is encoded into the amplitude and phase of a
sample.
The modem structure implements a variety of common modulation schemes,
including (differential) phase-shift keying, and (quadrature) amplitude-shift
keying.
The input/output relationship for modulation/demodulation for the {\tt modem}
object is
strictly one-to-one and is independent of any pulse shaping, or interpolation.
%This differs from {\tt cpmodem} in which the pulse shaping filter is
%integrated into the modem itself.

In general, linear modems demodulate by finding the closest of $M$
symbols in the set $\mathcal{S}_M$ to the received symbol $r$, viz
%
\begin{equation}
\label{eqn:modem:demod}
    \underset{k \in \mathcal{S}_M}{\arg\min}
    \bigl\{
        \| r - s_k \|
    \bigr\}
\end{equation}
%
For arbitrary modulation schemes a linear search over all symbols in
$\mathcal{S}$ is required which has a complexity of $\ord(M^2)$, however one may
take advantage of symmetries in certain constellations to reduce this.
%For example, $M$-ary PSK distributes its symbols evenly throughout the phase
%of the transmitted signal...

% ------------ TABLE: LINEAR MODULATION SCHEMES ------------
\begin{table*}
\caption{Linear Modulation Schemes Available in \liquid}
\label{tab:modem:schemes}
\centering
{\small
\begin{tabular*}{0.95\textwidth}{l@{\extracolsep{\fill}}ll}
\toprule
{\it scheme} &
{\it range of depth} &
{\it description}\\\otoprule
%
{\tt MOD\_UNKNOWN}      & -     & unknown/unsupported scheme\\
{\tt MOD\_PSK}          & 1|8   & phase-shift keying\\
{\tt MOD\_DPSK}         & 1|8   & differential phase-shift keying\\
{\tt MOD\_ASK}          & 1|8   & amplitude-shift keying\\
{\tt MOD\_QAM}          & 2|8   & quadrature amplitude-shift keying\\
{\tt MOD\_APSK}         & 2|7   & amplitude/phase-shift keying\\
{\tt MOD\_ARB}          & 1|8   & arbitrary signal constellation\\\midrule
%
{\tt MOD\_BPSK}         & 1     & binary phase-shift keying\\
{\tt MOD\_QPSK}         & 2     & quaternary phase-shift keying\\
{\tt MOD\_APSK4}        & 2     & amplitude/phase-shift keying, $M=4$, (1,3)\\
{\tt MOD\_APSK8}        & 3     & amplitude/phase-shift keying, $M=8$, (1,7)\\
{\tt MOD\_APSK16}       & 4     & amplitude/phase-shift keying, $M=16$, (4,12)\\
{\tt MOD\_APSK32}       & 5     & amplitude/phase-shift keying, $M=32$, (4,12,16)\\
{\tt MOD\_APSK64}       & 6     & amplitude/phase-shift keying, $M=64$, (4,14,20,26)\\
{\tt MOD\_APSK128}      & 7     & amplitude/phase-shift keying, $M=128$, (8,18,24,36,42)\\
{\tt MOD\_ARB16OPT}     & 4     & optimal 16-QAM\\
{\tt MOD\_ARB64VT}      & 6     & Virginia Tech logo\\\bottomrule
% 
\end{tabular*}
}
\end{table*}%
% ------------------------


\subsubsection{Interface}
\label{module:modem:digital:interface}
\begin{description}
\item[{\tt modem\_create(scheme,bps)}]
    creates a linear modulator/demodulator {\tt modem} object with one
    of the schemes defined in Table~\ref{tab:modem:schemes}
    with {\tt bps} bits per symbol.
\item[{\tt modem\_destroy(q)}]
    destroys a {\tt modem} object, freeing all internally-allocated
    memory.
\item[{\tt modem\_print(q)}]
    prints the internal state of the object.
\item[{\tt modem\_reset(q)}]
    resets the internal state of the object.
    This method is really only relevant to {\tt MOD\_DPSK}
    (differential phase-shift keying) which retains the phase of the
    previous symbol in memory.
    All other modulation schemes are memoryless.
\item[{\tt modem\_arb\_init(q,*map,n)}]
    initializes an arbitrary modem ({\tt MOD\_ARB}) with the $n$-point
    constellation map.
    The resulting constellation is normalized such that it is centered
    at zero and has unity energy.
\item[{\tt modem\_arb\_init\_file(q,*filename)}]
    initializes an arbitrary modem ({\tt MOD\_ARB}) with a constellation
    map defined in an external file.
    The file includes one line per symbol with the in-phase and
    quadrature components separated by white space, e.g.
    %
    \begin{Verbatim}[fontsize=\small]
       1.46968   0.13529
       1.69067   0.71802
      -0.85603   0.43542
      -0.56563   1.50369
       0.45232   0.42128
          ...
    \end{Verbatim}
    %
    The resulting constellation is normalized such that it is centered
    at zero and has unity energy.
\item[{\tt modem\_modulate(q,symbol,*x)}]
    modulates the integer symbol storing the result in the output value
    of $x$.
    The input symbol value must be less than the constellation size $M$.
\item[{\tt modem\_demodulate(q,x,*symbol)}]
    finds the closest integer symbol which matches the input sample $x$.
    The exact method by which \liquid\ performs this computation is
    dependent upon the modulation scheme.
    For example, while
    {\tt MOD\_QAM} ($M=4$), and
    {\tt MOD\_PSK} ($M=4$)
    are effectively equivalent (four points on the unit circle)
    they are demodulated differently.
\item[{\tt modem\_get\_demodulator\_phase\_error(q)}]
    returns an angle proportional to the phase error after demodulation.
    This value can be used in a phase-locked loop
    (see Section~\ref{module:nco:pll})
    to correct for carrier phase recovery.
\item[{\tt modem\_get\_demodulator\_evm(q)}]
    returns a value equal to the error vector magnitude after demodulation.
    The error vector is the difference between the received symbol and the
    estimated transmitted symbol, $e = r - \hat{s}$.
    The magnitude of the error vector is an indication to the
    signal-to-noise/distortion ratio at receiver.
\end{description}

While the same modem structure may be used for both modulation and
demodulation for most schemes, it is important to use separate objects
for differential-mode modems (e.g. {\tt MOD\_DPSK}) as the internal state
will change after each symbol.
It is usually good practice to keep separate instances of modulators and
demodulators.
This holds true for most any encoder/decoder pair in \liquid.

\subsubsection{Gray coding}
\label{module:modem:digital:gray_coding}
In order to reduce the number of bit errors in a digital modem,
all symbols are automatically Gray encoded;
adjacent symbols in a constellation differ by only one bit.
%
For example, the binary-coded decimal (bcd) value of 183 is {\tt 10110111}.
It has adjacent symbol 184 ({\tt 10111000}) which differs by 4 bits.
Assume the transmitter sends 183 without encoding.
If noise at the receiver were to cause it to demodulate the nearby symbol 184,
the result would be 4 bit errors.
%
Gray encoding is computed to the binary-coded decimal symbol
by applying an exclusive OR bitmask of itself shifted to the right by a
single bit.
\begin{verbatim}
        10110111    bcd_in (183)        10111000    bcd_in (184)
        .1011011    bcd_in >> 1         .1011100    bcd_in >> 1
xor :   --------                        --------
        11101100    gray_out (236)      11100100    gray_out (228)
\end{verbatim}
Notice that the two output symbols
236 ({\tt 11101100}) and
228 ({\tt 11100100}) differ by only one bit.
Now if noise caused the receiver were to demodulate a symbol error, it would
result in only a single bit error instead of 4 without Gray coding.

The decoding process is similar to encoding but slightly more involved.
Gray decoding is computed on an encoded input symbol
by adding to it (modulo 2) as many shifted versions of itself as it has bits.
\begin{verbatim}
        11101100    gray_in (236)       11100100    gray_in (228)
        .1110110    gray_in >> 1        .1110010    gray_in >> 1
        ..111011    gray_in >> 2        ..111001    gray_in >> 2
        ...11101    gray_in >> 3        ...11100    gray_in >> 3
        ....1110    gray_in >> 4        ....1110    gray_in >> 4
        .....111    gray_in >> 5        .....111    gray_in >> 5
        ......11    gray_in >> 6        ......11    gray_in >> 6
        .......1    gray_in >> 7        .......1    gray_in >> 7
xor :   --------                        --------
        10110111    gray_out (183)      10111000    gray_out (184)
\end{verbatim}
There are a few interesting characteristics of Gray encoding:
\begin{itemize}
\item the first bit never changes in encoding/decoding
\item there is a unique mapping between input and output symbols
\end{itemize}
It is also interesting to note that in linear modems (e.g. PSK), the
{\tt decoder} is actually applied to the symbol at the transmitter while the
{\tt encoder} is applied to the received symbol at the receiver.
%This is somewhat counterintuitive and is because...
In \liquid, Gray encoding and decoding are computed with the
{\tt gray\_encode()} {\tt gray\_decode()} methods, respectively.

\subsubsection{{\tt MOD\_PSK} (phase-shift keying)}
\label{module:modem:digital:PSK}
Demodulation is performed independent of the signal amplitude.
For an $M$-symbol constellation, the $k^{th}$ symbol is
\[
    s_k = e^{j 2 \pi k/M}
\]
where $k \in \{0,1,\ldots,M-1\}$.
Specific schemes include BPSK ($M=2$),
\[
    s_k = e^{j \pi k} =
    \begin{cases}
        +1 & k=0 \\
        -1 & k=1
    \end{cases}
\]
and QPSK ($M=4$)
\[
    s_k = e^{j\left(\pi k/4 + \frac{\pi}{4}\right)}
\]

%-------------------- FIGURE: PSK MODEM --------------------
\begin{figure}
\centering
\mbox{
  \subfigure[BPSK]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_bpsk}
      \label{fig:modem:psk:2}
    } \quad
  \subfigure[QPSK]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_qpsk}
      \label{fig:modem:psk:4}
    } \quad
}
\mbox{
  \subfigure[8-PSK]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_8psk}
      \label{fig:modem:psk:8}
    } \quad
  \subfigure[16-PSK]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_16psk}
      \label{fig:modem:psk:16}
    } \quad
}
% trim = left bottom right top
\caption{Phase-shift keying (PSK) modem}
\label{fig:modem:psk}
\end{figure}

\subsubsection{{\tt MOD\_DPSK} (differential phase-shift keying)}
\label{module:modem:digital:DPSK}
Demodulation is performed independent of the signal amplitude.
The data are encoded using phase transitions, rather than absolute phase.
This allows the receiver to demodulate incoherently, but at a quality
degradation of 3dB.
\[
    s_k(n) = \exp\left\{
                \frac{
                    j 2 \pi \Bigl(k(n) - k(n-1)\Bigr)
                } {
                    M
                }
            \right\}
\]

\subsubsection{{\tt MOD\_APSK} (amplitude/phase-shift keying}
\label{module:modem:digital:APSK}
Amplitude/phase-shift keying is a specific form of quadrature amplitude
modulation where constellation points lie on concentric circles.
\begin{itemize}
\item constellation points are further apart than those of PSK/DPSK, resulting
      in an improved error performance,
\item phase recovery is improved over regular QAM as the constellation points
      are less sensitive to phase noise
\end{itemize}
Demodulation follows as a two-step process: first, the amplitude of the
received signal is evaluated to determine in which level (``ring'') the
transmitted symbol lies.
Once the level is determined, the appropriate symbol is chosen based on its
phase, similar to PSK demodulation.
Demodulation of APSK consumes slightly more clock cycles than the PSK and QAM
demodulators.

%-------------------- FIGURE: APSK MODEM --------------------
\begin{figure}
\centering
\mbox{
  \subfigure[4-APSK (1,3)]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_4apsk}
      \label{fig:modem:apsk:4}
    } \quad
  \subfigure[8-PSK (1,7)]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_8apsk}
      \label{fig:modem:apsk:8}
    } \quad
}
\mbox{
  \subfigure[16-APSK (4,12)]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_16apsk}
      \label{fig:modem:apsk:16}
    } \quad
  \subfigure[32-APSK (4,12,16)]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_32apsk}
      \label{fig:modem:apsk:32}
    } \quad
}
\mbox{
  \subfigure[64-APSK (4,14,20,26)]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_64apsk}
      \label{fig:modem:apsk:64}
    } \quad
  \subfigure[128-APSK (8,18,24,36,42)]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_128apsk}
      \label{fig:modem:apsk:128}
    } \quad
}
% trim = left bottom right top
\caption{Amplitude/phase-shift keying (APSK) modem}
\label{fig:modem:apsk}
\end{figure}

\subsubsection{{\tt MOD\_ASK} (amplitude-shift keying)}
\label{module:modem:digital:ASK}

\[
    s_k = \alpha ( 2 k - M - 1 )
\]
where $\alpha$ is a scaling factor to ensure $E\{s_k^2\}=1$,
\[
    \alpha = 
    \begin{cases}
    1               &   M=2     \\
    1/\sqrt{5}      &   M=4     \\
    1/\sqrt{21}     &   M=8     \\
    1/\sqrt{85}     &   M=16    \\
    1/\sqrt{341}    &   M=32    \\
    \sqrt{3}/M      &   M > 32
    \end{cases}
\]

%-------------------- FIGURE: ASK MODEM --------------------
\begin{figure}
\centering
\mbox{
  \subfigure[2-ASK]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_2ask}
      \label{fig:modem:ask:2}
    } \quad
  \subfigure[4-ASK]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_4ask}
      \label{fig:modem:ask:4}
    } \quad
}
\mbox{
  \subfigure[8-ASK]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_8ask}
      \label{fig:modem:ask:8}
    } \quad
  \subfigure[16-ASK]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_16ask}
      \label{fig:modem:ask:16}
    } \quad
}
% trim = left bottom right top
\caption{Pulse-amplitude modulation (ASK) modem}
\label{fig:modem:ask}
\end{figure}

\subsubsection{{\tt MOD\_QAM} (quadrature amplitude modulation)}
\label{module:modem:digital:QAM}
Also known as quadrature amplitude-shift keying, QAM modems encode data using
both the in-phase and quadrature components of a signal amplitude.
In fact, the symbol is split into independent in-phase and quadrature symbols
which are encoded separately as {\tt MOD\_ASK} symbols.
Gray encoding is applited to both the I and Q symbols separately to help
ensure minimal bit changes between adjacent samples across both in-phase and
quadrature-phase dimensions.
This is made evident in Figure~\ref{fig:modem:qam:64} where one can see that
the first three bits of the symbol encode the in-phase component of the
sample, and the last thre bits encode the quadrature component of the sample.
%
We may formally describe the encoded sample is
\[
    s_k = \alpha \{ ( 2 k_i - M_i - 1 ) + j(2 k_q - M_q - 1) \}
\]
where
$k_i$ is the in-phase symbol,
$k_q$ is the quadrature symbol,
$M_i = 2^{m_i}$ and $M_q = 2^{m_q}$, are the number of respective in-phase and
quadrature symbols,
$m_i=\lceil \log_2(M) \rceil$ and $m_q=\lfloor \log_2(M) \rfloor$ are the
number of respective in-phase and quadrature bits, and
$\alpha$ is a scaling factor to ensure $E\{s_k^2\}=1$,
\[
    \alpha = 
    \begin{cases}
    1/\sqrt{2}      &   M=4     \\
    1/\sqrt{6}      &   M=8     \\
    1/\sqrt{10}     &   M=16    \\
    1/\sqrt{26}     &   M=32    \\
    1/\sqrt{42}     &   M=64    \\
    1/\sqrt{106}    &   M=128   \\
    1/\sqrt{170}    &   M=256   \\
    1/\sqrt{426}    &   M=512   \\
    1/\sqrt{682}    &   M=1024  \\
    1/\sqrt{1706}   &   M=2048  \\
    1/\sqrt{2730}   &   M=4096  \\
    \sqrt{2/M}      &   \text{else}
    \end{cases}
\]


%-------------------- FIGURE: QAM MODEM --------------------
\begin{figure}
\centering
\mbox{
  \subfigure[8-QAM]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_8qam}
      \label{fig:modem:qam:8}
    } \quad
  \subfigure[16-QAM]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_16qam}
      \label{fig:modem:qam:16}
    } \quad
}
\mbox{
  \subfigure[32-QAM]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_32qam}
      \label{fig:modem:qam:32}
    } \quad
  \subfigure[64-QAM]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_64qam}
      \label{fig:modem:qam:64}
    } \quad
}
\mbox{
  \subfigure[128-QAM]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_128qam}
      \label{fig:modem:qam:128}
    } \quad
  \subfigure[256-QAM]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_256qam}
      \label{fig:modem:qam:256}
    } \quad
}
% trim = left bottom right top
\caption{Rectangular quaternary-amplitude modulation (QAM) modem}
\label{fig:modem:qam}
\end{figure}

\subsubsection{{\tt MOD\_ARB} (arbitrary modem)}
\label{module:modem:digital:ARB}
\liquid\ also allows the user to create their own modulation schemes by
designating the number of bits per symbol, and the full signal constellation.
Several pre-loaded arbitrary signal constellations are available.

%-------------------- FIGURE: ARB MODEM --------------------
\begin{figure}
\centering
\mbox{
  \subfigure[optimal 16-QAM]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_arb16opt}
      \label{fig:modem:arb:16opt}
    } \quad
  \subfigure[64-VT]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/modem_arb64vt}
      \label{fig:modem:arb:64vt}
    } \quad
}
% trim = left bottom right top
\caption{Arbitrary constellation (ARB) modem}
\label{fig:modem:arb}
\end{figure}


