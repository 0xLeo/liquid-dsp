% 
% MODULE : math
%

\newpage
\section{math}
\label{module:math}
The {\tt math} module implements several useful functions for digital
signal processing including trascendental function not necessarily in
the standard C library,
windowing functions,
and polynomial manipulation methods.

\subsection{transcendental functions}
\label{module:math:transcendentals}
transcendental functions not in the C standard library (gamma, besseli, etc.)


\subsubsection{{\tt liquid\_lngammaf()}}
\label{module:math:transcendentals:lngamma}
    computes the natural log of the complete gamma function by splitting into
    discrete piecewise sections:
\[
    \ln\left[ \Gamma(z) \right] \approx
    \begin{cases}
    % undefined for z < 0
        \text{undefined}
        & z < 0 \\
    % low signal approximation
        -\ln(z) - \gamma z - \sum_{n=1}^{\infty} {
            \left[ \ln(1 + z/n) -z/n\right]
        }
        & 0 \le z < 0.6 \\
    % high signal approximation
        \frac{z}{2} \ln\left( \frac{2\pi}{z} \right)
        \left(
            \ln\left(z + \frac{1}{12 z - 0.1/z} \right) - 1
        \right)
        & z \ge 0.6
    \end{cases}
\]
where $\gamma=0.57721566490153286\ldots$ is the Euler-Mascheroni constant.

\subsubsection{{\tt liquid\_sincf()}}
\label{module:math:transcendentals:sinc}
    computes the $\sinc$ function,
\[
    \sinc(z) = \frac{\sin(\pi z)}{\pi z}
\]
Simply evaluating the above equation with finite precision for $z$ results in
a discontinuity for small $z$, and is approximated by expanding the first few
terms of the series
\[
    \sinc(z) = \prod_{k=1}^{\infty}{ \cos\left( 2^{-k} \pi z \right) }
\]

\subsubsection{{\tt liquid\_besseli0()}}
\label{module:math:transcendentals:besseli0}
    approximates the modified Bessel function of the first kind (order 0)
    using piecewise polynomials,
\[
    \ln\Bigl[\ln\left(I_0(z)\right)\Bigr] \approx
    c_0 + c_1 t + c_2 t ^2 + c_3 t^3
\]
where $t=\ln(z)$ and
\[
    \left\{c_0,c_1,c_2,c_3\right\} =
    \begin{cases}
    \left\{\text{-1.52624, 1.9597, -9.4287e-03, -7.0471e-04}\right\} & t < 0.5 \\
    \left\{\text{-1.5531, 1.8936, -0.07972, -0.01333}\right\} & 0.5 \le t < 2.3 \\
    \left\{\text{-1.2958, 1.7693, -0.1175, 0.006341}\right\} & \text{else}.
    \end{cases}
\]
This is a particularly useful approximation for the Kaiser window in
fixed-point math where $w[n]$ is computed as the ratio of two large numbers.
%
An iterative method comes from Gross(1995),
%\cite{Gross:1995}
\[
    I_\nu(z) = \sum_{k=0}^{\infty}{\frac{\left(\frac{1}{4}z^2\right)^k}{k!\Gamma(k+\nu+1)}}
\]

\subsubsection{{\tt liquid\_nchoosek()}}
\label{module:math:transcendentals:nchoosek}
    computes the binomial coefficient ${n \choose k} = \frac{n!}{(n-k)!k!}$

\subsubsection{{\tt liquid\_nextpow2()}}
\label{module:math:transcendentals:nextpow2}
    computes $\lceil \log_2(x) \rceil$



\subsection{Complex Trigonometry}
\label{module:math:complex}
Complex math operations not necessarily defined in the standard C
library.

\subsubsection{{\tt liquid\_csqrtf()}}
\label{module:math:complex:csqrtf}
The function {\tt liquid\_csqrtf()}
computes the complex square root of a number
%
\begin{equation}
\label{eqn:math:csqrtf}
    \sqrt{z} = \sqrt{\frac{r+a}{2}} +
               j\text{sgn}\bigl(\Im\{z\}\bigr)
               \sqrt{\frac{r-a}{2}}
\end{equation}
%
where $r=|z|$, $a=\Re\{z\}$, and $\text{sgn}(t)=t/|t|$.

\subsubsection{{\tt liquid\_cexpf()}}
\label{module:math:complex:cexpf}
The function {\tt liquid\_cexpf()}
computes the complex exponential of a number
%
\begin{equation}
\label{eqn:math:cexpf}
    e^{z} = \exp\bigl\{a\bigr\}
            \bigl(
                \cos(b) + j\sin(b)
            \bigr)
\end{equation}
%
where $a=\Re\{z\}$ and $b=\Im\{z\}$.


\subsubsection{{\tt liquid\_clogf()}}
\label{module:math:complex:clogf}
The function {\tt liquid\_clogf()}
computes the complex natural logarithm of a number.
%
\begin{equation}
\label{eqn:math:clogf}
    \log(z) =   \log(|z|) + j\arg(z)
\end{equation}
%


\subsubsection{{\tt liquid\_cacosf()}}
\label{module:math:complex:cacosf}
The function {\tt liquid\_cacosf()}
computes the complex $\arccos$ of a number
%
\begin{equation}
\label{eqn:math:cacosf}
    \arccos(z) =
        \begin{cases}
        -j \log\bigl( z + \sqrt{z^2 - 1} \bigr) &
            \text{sgn}\bigl(\Re\{z\}\bigr) =
            \text{sgn}\bigl(\Im\{z\}\bigr) \\
        -j \log\bigl( z - \sqrt{z^2 - 1} \bigr) & \text{otherwise}
        \end{cases}
\end{equation}
%


\subsubsection{{\tt liquid\_casinf()}}
\label{module:math:complex:casinf}
The function {\tt liquid\_casinf()}
computes the complex $\arcsin$ of a number
%
\begin{equation}
\label{eqn:math:casinf}
    \arcsin(z) = \frac{\pi}{2} - \arccos(z)
\end{equation}
%



\subsubsection{{\tt liquid\_catanf()}}
\label{module:math:complex:catanf}
The function {\tt liquid\_catanf()}
computes the complex $\arctan$ of a number
%
\begin{equation}
\label{eqn:math:catanf}
    \arctan(z) =
        \frac{j}{2}
        \log\left( \frac{1-jz}{1+jz} \right)
\end{equation}
%


\subsection{Windowing functions}
\label{module:math:window}
This section describes the various windowing functions in the {\tt math}
module.
These windowing functions are useful for spectral approximation as they
are compact in both the time and frequency domains.

\subsubsection{Hamming}
\label{module:math:window:hamming}
The function {\tt hamming()} computes the Hamming window
%
\begin{equation}
\label{eqn:math:window:hamming}
    w(n) = 0.53836 - 0.46164 \cos\left( 2 \pi n / (N-1) \right)
\end{equation}
%

\subsubsection{Hann}
\label{module:math:window:hann}
The function {\tt hann()} computes the Hann window
%
\begin{equation}
\label{eqn:math:window:hann}
    w(n) = 0.5 - 0.5 \cos\left( 2 \pi n / (N-1) \right)
\end{equation}
%

\subsubsection{Blackman-harris}
\label{module:math:window:blackmanharris}
The function {\tt blackmanharris()}
    computes the Blackman-harris window
%
\begin{equation}
\label{eqn:math:window:blackmanharris}
    w(n) = \sum_{k=0}^{3} { a_k \cos\left( 2 \pi k n / (N-1)\right) }
\end{equation}
%
where
$a_0 =  0.35875$,
$a_1 = -0.48829$,
$a_2 =  0.14128$, and
$a_3 = -0.01168$.

\subsubsection{Kaiser}
\label{module:math:window:kaiser}
The function {\tt kaiser()} computes the Kaiser-$\beta$ window
%
\begin{equation}
\label{eqn:math:window:kaiser}
    w(n,\beta) = \frac{
        I_0\left(\pi\beta\sqrt{1-\left(\frac{n}{N/2}^2\right)}\right)
    }{
        I_0\left(\pi\beta\right)
    }
\end{equation}
%
where $I_\nu(z)$ is the modified Bessel function of the first kind of
order $\nu$, and $\beta$ is a parameter controlling the width of the
window and its stop-band attenuation.
In \liquid, $I_0(z)$ is computed using {\tt liquid\_besseli0()} (see
section~\ref{module:math:transcendentals}).

\subsubsection{Kaiser-Bessel derived}
\label{module:math:window:kbd}
The function {\tt liquid\_kbd\_window()}
computes the Kaiser-Bessel derived window.
The length of the window {\em must} be even.

\subsubsection{Examples}
\label{module:math:window:examples}

Temporal and spectral examples of all these windows can be seen in
figure~\ref{fig:module:math:window}.
Notice that as the power spectral density main lobe increases in width, its
stop-band attenuation decreases.
Furthermore, windows with wider temporal widths exhibit more narrow spectral
main lobes, but have less stop-band attenuation.

\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/math_window}
\caption{windowing functions, power spectral density}
\label{fig:module:math:window}
\end{figure}

\subsection{Polynomials}
\label{module:math:poly}
A number of \liquid\ modules require polynomial manipulations, particularly
those involving filter design where transfer functions are represented as the
explicit ratio of polynomials in $z^{-1}$.
This sub-module is not intended to be complete, but rather is required for
the proper functionality of other modules.
Like matrices, polynomials in \liquid\ do not use a particular data type, but
are stored as memory arrays.
%
\begin{equation}
\label{eqn:math:poly:representation}
    P_n(x) = \sum_{k=0}^{n}{c_k x^k}
           = c_0 + c_1 x + c_2 x^2 + \cdots + c_n x^n
\end{equation}
%
An $n^{th}$-order polynomial has $n+1$ coefficients ordered in memory in
increasing degree.%
\footnote{Note that this convention is reversed from that used in octave
\cite{octave:web}.}
For example, a $2^{nd}$-order polynomial $0.1 -2.4x + 1.3x^2$ stored in an
array {\tt float c[]} has
{\tt c[0]=0.1},
{\tt c[1]=-2.4}, and
{\tt c[2]=1.3}.

\subsubsection{{\tt poly\_val()}}
\label{module:math:poly:polyf_val}
Evaluates the polynomial $P_n(x)$ at $x_0$.
For example:
\begin{Verbatim}[fontsize=\small]
    float p[3] = {0.2f, 1.0f, 0.4f};
    float x = 1.3f;
    float y = polyf_val(p,3,x);
    >>> y = 2.17599988
\end{Verbatim}

\subsubsection{{\tt poly\_fit()}}
\label{module:math:poly:polyf_fit}
Fits data to a polynomial of order $k-1$ from $n$ samples using the
least-squares method.
Data vectors
$\vec{x}=[x_0,x_1,\cdots,x_{n-1}]^T$ and 
$\vec{y}=[y_0,y_1,\cdots,y_{n-1}]^T$...
Uses matrix algebra to solve system of equations...
%
\begin{equation}
\label{eqn:math:poly:syseq}
    \vec{p} = \left(\vec{X}^T\vec{X}\right)^{-1}\vec{X}^T\vec{y}
\end{equation}
%
where
%
\begin{equation}
\label{eqn:math:poly:polyfit}
    \vec{X} = 
    \begin{bmatrix}
        1   & x_0       & x_0^2     & \cdots    & x_0^{k}     \\
        1   & x_1       & x_1^2     & \cdots    & x_1^{k}     \\
        \\
        1   & x_{n-1}   & x_{n-1}^2 & \cdots    & x_{n-1}^{k}
    \end{bmatrix}
\end{equation}
%
For example this script fits the 4 data samples to a linear
(first-order, two coefficients) polynomial:
%
\begin{Verbatim}[fontsize=\small]
    float x[4] = {0.0f,  1.0f,  2.0f,  3.0f};
    float y[4] = {0.85f, 3.07f, 5.07f, 7.16f};
    float p[2];
    polyf_fit(x,y,4,p,2);
    >>> p = {  0.89800072,   2.09299946}
\end{Verbatim}


\subsubsection{{\tt poly\_fit\_lagrange()}}
\label{module:math:poly:polyf_fit_lagrange}
Fits dataset of $n$ sample points to exact polynomial of order $n-1$ using
Lagrange interpolation.
Given input vectors
$\vec{x}=[x_0,x_1,\cdots,x_{n-1}]^T$ and 
$\vec{y}=[y_0,y_1,\cdots,y_{n-1}]^T$, the interpolating polynomial is
%
\begin{equation}
\label{eqn:math:poly:polyfit_lagrange}
    P_{n-1}(x) =
        \sum_{j=0}^{n-1} {
            \left[
            y_j
            \prod_{{k=0}\atop{k \ne j}}^{n-1} {
                \frac{x-x_k}{x_j-x_k}
            }
            \right]
        }
\end{equation}
%
For example this script fits the 4 data samples to a cubic
(third-order, four coefficients) polynomial:
%
\begin{Verbatim}[fontsize=\small]
    float x[4] = {0.0f,  1.0f,  2.0f,  3.0f};
    float y[4] = {0.85f, 3.07f, 5.07f, 7.16f};
    float p[4];
    polyf_fit_lagrange(x,y,4,p);
    >>> p = {  0.85000002,   2.43333268,  -0.26499939,   0.05166650}
\end{Verbatim}
%
Notice that {\tt polyf\_fit\_lagrange(x,y,n,p)}
is mathematically equivalent to {\tt polyf\_fit(x,y,n,p,n)},
but is computed in fewer steps.
%
See also {\tt poly\_expandroots}.

\subsubsection{{\tt poly\_interp\_lagrange()}}
\label{module:math:poly:polyf_interp_lagrange}
Uses Lagrange polynomials to find the interpolant
$(\dot{x},\dot{y})$ from a set of $n$ pairs
$\vec{x}=[x_0,x_1,\cdots,x_{n-1}]^T$ and 
$\vec{y}=[y_0,y_1,\cdots,y_{n-1}]^T$.
%
\begin{equation}
\label{eqn:math:poly:polyinterp_lagrange}
    \dot{y} =
        \sum_{j=0}^{n-1} {
            \left[
            y_j
            \prod_{{k=0}\atop{k \ne j}}^{n-1} {
                \frac{\dot{x}-x_k}{x_j-x_k}
            }
            \right]
        }
\end{equation}
%
For example this script interpolates between the 4 data points
%
\begin{Verbatim}[fontsize=\small]
    float x[4] = {0.0f,  1.0f,  2.0f,  3.0f};
    float y[4] = {0.85f, 3.07f, 5.07f, 7.16f};
    float x0 = 0.5f;
    float y0 = polyf_interp_lagrange(x,y,4,x0);
    >>> y0 =   2.00687504
\end{Verbatim}
%
See also {\tt poly\_fit\_lagrange()}.

\subsubsection{{\tt poly\_fit\_lagrange\_barycentric()}}
\label{module:math:poly:polyf_fit_lagrange_barycentric}
Computes the barycentric weights $\vec{w}$ of $\vec{x}$ via
%
\begin{equation}
\label{eqn:math:poly:polyfit_lagrange_barycentric}
    w_j =   \frac{1}{
                \prod_{k \ne j}{\left(x_j - x_k\right)}
            }
\end{equation}
%
which can be used to compute the interpolant $(\dot{x},\dot{y})$
with fewer computations.
%
\begin{Verbatim}[fontsize=\small]
    float x[4] = {0.0f,  1.0f,  2.0f,  3.0f};
    float w[4];
    polyf_fit_lagrange_barycentric(x,4,w);
    >>> w = {  1.00000000,  -3.00000000,   3.00000000,  -1.00000000}
\end{Verbatim}
%

\subsubsection{{\tt poly\_val\_lagrange\_barycentric()}}
\label{module:math:poly:polyf_val_lagrange_barycentric}
Computes the interpolant $(\dot{x},\dot{y})$ given the barycentric
weights $\vec{w}$ (defined above) as
%
\begin{equation}
\label{eqn:math:poly:polyval_lagrange_barycentric}
    \dot{y} =   \frac{
                    \sum\limits_{j=0}^{k-1}{ w_j y_j /(\dot{x}-x_j) }
                } {
                    \sum\limits_{j=0}^{k-1}{     w_j /(\dot{x}-x_j) }
                }
\end{equation}
%
This is the preferred method for computing Lagrange interpolating polynomials,
particularly if $\vec{x}$ is unchanging.
The function returns $\dot{y}$ if $\dot{x}$ is equal to any $x_j$.
%
\begin{Verbatim}[fontsize=\small]
    float x[4] = {0.0f,  1.0f,  2.0f,  3.0f};
    float y[4] = {0.85f, 3.07f, 5.07f, 7.16f};
    float w[4]; 
    polyf_fit_lagrange_barycentric(x,4,w);
    float x0 = 0.5f;
    float y0 = polyf_val_lagrange_barycentric(x,y,w,x0,4);
    >>> y0 =   2.00687504
\end{Verbatim}
%
Lagrange polynomials of the barycentric form are used heavily in
\liquid's implementation of the Parks-McClellan algorithm
({\tt firdespm}) for filter design
(see Section~\ref{module:filter:firdespm}).

\subsubsection{{\tt poly\_expandroots()}}
\label{module:math:poly:polyf_expandroots}
Expands the a polynomial based on its roots
%
\begin{equation}
\label{eqn:math:poly:expandroots}
    P_n(x) = \prod_{k=0}^{n-1}{(x - r_k)}
\end{equation}
%
where $r_k$ are the roots of $P_n(x)$.
For example, this script will expand the polynomial
$P_3(x) = (x-1)(x+2)(x-3)$ which has roots
$\{1,-2,3\}$:
%
\begin{Verbatim}[fontsize=\small]
    float roots[3] = {1.0f, -2.0f, 3.0f};
    float p[4];
    polyf_expandroots(roots,3,p);
    >>> p = {  6.00000000,  -5.00000000,  -2.00000000,   1.00000000}
\end{Verbatim}
%

\subsubsection{{\tt poly\_expandroots2()}}
\label{module:math:poly:polyf_expandroots2}
Expands the a polynomial as
%
\begin{equation}
\label{eqn:math:poly:expandroots2}
    P_n(x) = \prod_{k=0}^{n-1}{(b_kx-a_k)}
\end{equation}
%
by first factoring out the $b_k$ terms,
invoking {\tt poly\_expandroots()}, and
multiplying the result by $\prod_k{b_k}$.
For example, this script will expand the polynomial
$P_3(x) = (2x-1)(-3x+2)(-x-3)$:
%
\begin{Verbatim}[fontsize=\small]
    float b[3] = { 2.0f, -3.0f, -1.0f};
    float a[3] = { 1.0f, -2.0f,  3.0f};
    float p[4];
    polyf_expandroots2(b,a,3,p);
    >>> p = {  6.00000000,  11.00000000, -19.00000000,   6.00000000}
\end{Verbatim}
%

\subsubsection{{\tt poly\_expandbinomial()}}
\label{module:math:poly:polyf_expandbinomial}
Expands the a polynomial as a binomial series
%
\begin{equation}
\label{eqn:math:poly:expandbinomial}
    P_n(x) = (x+1)^n = \sum_{k=0}^{n}{ {n \choose k} x^k}
\end{equation}
%
For example the following script will compute
$P_3(x) = (1+x)^3$:
%
\begin{Verbatim}[fontsize=\small]
    float p[4];
    polyf_expandbinomial(3,p);
    >>> p = {  1.00000000,   3.00000000,   3.00000000,   1.00000000}
\end{Verbatim}
%

\subsubsection{{\tt poly\_expandbinomial\_pm()}}
\label{module:math:poly:polyf_expandbinomial_pm}
Expands the a polynomial as an alternating binomial series
%
\begin{equation}
\label{eqn:math:poly:expandbinomial_pm}
    P_n(x) = (x+1)^m (x-1)^{n-m}
           = \left\{ \sum_{k=0}^{m}  { {n \choose k}    x^k} \right\}
             \left\{ \sum_{k=0}^{n-m}{ {n \choose k} (-x)^k} \right\}
\end{equation}
%
For example the following script will compute
$P_3(x) = (1+x)^2(1-x)$:
%
\begin{Verbatim}[fontsize=\small]
    float p[4];
    polyf_expandbinomial_pm(2,1,p);
    >>> p = {  1.00000000,   1.00000000,  -1.00000000,  -1.00000000}
\end{Verbatim}
%


\subsubsection{{\tt poly\_mul()}}
\label{module:math:poly:polyf_mul}
Multiplies two polynomials $P_n(x)$ and $Q_m(x)$.

%\subsubsection{{\tt poly\_diff()} {\it not yet implemented}}
%Computes the derivative $\frac{\partial}{\partial x}P_n(x)$ of polynomial
%$P_n(x)$
%\[
%    \frac{\partial}{\partial x}P_n(x) = \sum_{k=1}^{n}{c_{k}x^{k-1}}
%\]

\subsubsection{{\tt poly\_findroots()}}
\label{module:math:poly:polyf_findroots}
Finds the $n$ roots of the $n^{th}$-order polynomial using Bairstow's method
[TODO : add reference].
For an $n^{th}$-order polynomial $P_n(x)$ given by
%
\begin{equation}
\label{eqn:math:poly:roots}
    P_n(x) = \prod_{k=0}^{n-1}{(x-r_k)}
\end{equation}
%
there exists at least one quadratic polynomial $p_{2}(x)=u + vx + x^2$ which
exactly divides $P_{n}(x)$ and has two roots (possibly complex)
%
\begin{equation}
\label{eqn:math:poly:complex_roots}
    r_0 = \frac{1}{2}\left(-v-\sqrt{v^2-4u}\right), \; \\
    r_1 = \frac{1}{2}\left(-v+\sqrt{v^2-4u}\right)
\end{equation}
%
If indeed the roots $r_0$ and $r_1$ are complex, they are also complex
conjugates.
Bairstow's method uses Newtonian iterations to find a pair $u$ and $v$ which
are both finite and real-valued.
This method has several advantages over other methods
\begin{itemize}
\item iterations operate on real-valued math, even if the roots are complex
\item the algorithm is capable of handling multiple roots (unlike the
      Durand-Kerner method), i.e. $P_{n}(x) = (x-2)(x-2)(x-2)\cdots$
\item the algorithm does not rely on expanding the full polynomial and is
      therefore resilient to machine precision
\end{itemize}
Each iteration of Bairstow's algorithm reduces the original polynomial order
by two, eventually collapsing the polynomial.
The initial choice of $u$ and $v$ determine both algorithm convergence and
speed.

\liquid\ implements Bairstow's method with the {\tt poly\_findroots()}
function which accepts an $n^{th}$-order polynomial in standard expanded form
and computes its $n$ roots.
The last term of the polynomial (highest order) cannot be zero, otherwise the
algorithm will not converge.
%The roots are sorted by complex pairs according to
%{\tt liquid\_cplxpair()} (see section...)


