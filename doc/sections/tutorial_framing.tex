% 
% TUTORIAL : framing
%

\newpage
\section{Tutorial: Framing}
\label{tutorial:framing}

In the previous tutorials we have created only the basic building blocks
for wireless communication.
This tutorial puts them all together by introducing a very simple
framing structure for sending and receiving data over a wireless link.


%
% SUBSECTION : problem statement
%
\subsection{Problem Statement}
\label{tutorial:framing:problem}

...

For this tutorial we will be using the {\tt framegen64} and
{\tt framesync64} objects in \liquid.
As you might have guessed {\tt framegen64} is the frame generator object
(transmit side)
and {\tt framesync64} is the frame synchronizer
(receive side).
This is a very simple frame which accepts a 12-byte header and 64-byte
payload and assembles it into a 1280-sample frame at complex baseband.
The assembled frame is ready to be up-converted and transmitted over the
air.
The receiver streams raw samples at complex baseband to an instance of
the frame synchronizer which picks out frames and invokes a user-defined
callback function.
The synchronizer corrects for gain, carrier, and sample timing offsets
(channel impairments) in the complex baseband samples with a minimal
amount of pre-processing required by the user.

% FIGURE: framing:structure
\includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=16cm]{figures.pgf/framing_structure}


%
% SUBSECTION : 
%
\subsection{Setting up the Environment}
\label{tutorial:framing:environment}


%
% SUBSECTION : frame generator
%
\subsection{Creating the Frame Generator}
\label{tutorial:framing:framegen}
% talking points
%   * components to a frame
%       * header
%       * payload
%       * etc.
%   * options (m, beta)


%
% SUBSECTION : frame synchronizer
%
\subsection{Creating the Frame Synchronizer}
\label{tutorial:framing:framesync}
% talking points
%   * what framesync actually does
%       * gain control
%       * frame synchronization
%       * symbol timing recovery
%       * carrier phase recovery
%       * matched filtering
%       * demodulation
%       * frame decoding
%   * what is a callback function?

What is a callback function?
Put quite simply, a callback function is a function pointer that is
passed to the object so...

The {\tt framesync64} object has a callback function which has six
arguments and looks like this:
%
\begin{Verbatim}[fontsize=\small]
    int framesync64_callback(unsigned char *  _header,
                             int              _header_valid,
                             unsigned char *  _payload,
                             int              _payload_valid,
                             framesyncstats_s _stats,
                             void *           _userdata);
\end{Verbatim}
%
The callback is typically defined to be {\tt static} and is passed to
the instance of {\tt framesync64} object when it is created.
%
\begin{description}
\item[{\tt \_header}]
    This is a pointer to the 12 bytes of decoded header data.
    This pointer is not static and cannot be used after returning from
    the callback function.
\item[{\tt \_header\_valid}]
    This is simply a flag to indicate if the header passed its cyclic
    redundancy check
    (``{\tt 0}'' means invalid, ``{\tt 1}'' means valid).
    If the check fails then the header data most likely has been
    corrupted beyond the point that the internal error-correction code
    can recover.
    Proceed with caution!
\item[{\tt \_payload}]
    This is a pointer to the 64 bytes of decoded payload data.
    Like the header,
    this pointer is not static and cannot be used after returning from
    the callback function.
    This means that it needs to be copied locally for you to retain the
    data.
\item[{\tt \_payload\_valid}]
    This is simply a flag to indicate if the payload passed its cyclic
    redundancy check
    (``{\tt 0}'' means invalid, ``{\tt 1}'' means valid).
    As with the header,
    if this flag is zero then the payload most likely has errors in it.
    Some applications are error tolerant and so it is possible that the
    payload data are still useful.
    Typically, though, the payload should be discarded and a
    re-transmission request should be issued.
\item[{\tt \_stats}]
    The {\tt \_stats} object is a synchronizer statistics construct that
    indicates some useful PHY information to the user.
    We will ignore this information in our program, but it can be quite
    useful for certain applications.
    For more information on the {\tt framesyncstats\_s} structure, see
    Section~\ref{module:framing:framesyncstats_s}.
\item[{\tt \_userdata}]
    Remember that pointer you passed to the {\tt create()} method?
    That points is passed to the callback and can represent just about
    anything.
    Typically this is a pointer to another structure and is the method
    by which the decoded header and payload data are returned to the
    program outside of the callback.
\end{description}

Ok, so let's break down the frame synchronizer's operation.
When you receive samples at complex baseband...


%
% SUBSECTION : 
%
\subsection{Putting it All Together}
\label{tutorial:framing:xxx}
% talking points



%
% SUBSECTION : 
%
\subsection{Final Program}
\label{tutorial:framing:completed}

The final program is listed below,
and a copy of the source is located in the {\tt doc/tutorials/}
subdirectory.
%
\input{tutorials/framing_tutorial.c.tex}
%

% talking points:
%   * flexframe: advanced framing
%   * csma callbacks
%   * framesync properties

% extra credit
Under what circumstances does the synchronizer miss the frame?
For example, what is the minimum SNR level that is required to reliably
receive a frame?
the maximum carrier frequency offset?

% additional notes:
The ``random'' noise generated by the program will be seeded to the same
value every time the program is run.
A new seed can be initialized on the system's time (e.g. time of day) to
help generate new instances of random numbers each time the program is
run.
To do so, include the {\tt <time.h>} header to the top of your file and
add the following line to the beginning of your program:
%
\begin{Verbatim}[fontsize=\small]
    srand(time(NULL));
\end{Verbatim}
%

