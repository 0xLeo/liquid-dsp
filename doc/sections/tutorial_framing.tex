% 
% TUTORIAL : framing
%

\newpage
\section{Tutorial: Framing}
\label{tutorial:framing}

In the previous tutorials we have created only the basic building blocks
for wireless communication.
This tutorial puts them all together by introducing a very simple
framing structure for sending and receiving data over a wireless link.


%
% SUBSECTION : problem statement
%
\subsection{Problem Statement}
\label{tutorial:framing:problem}

...

For this tutorial we will be using the {\tt framegen64} and
{\tt framesync64} objects in \liquid.
As you might have guessed {\tt framegen64} is the frame generator object
(transmit side)
and {\tt framesync64} is the frame synchronizer
(receive side).
This is a very simple frame which accepts a 12-byte header and 64-byte
payload and assembles it into a 1280-sample frame at complex baseband.
The assembled frame is ready to be up-converted and transmitted over the
air.
The receiver streams raw samples at complex baseband to an instance of
the frame synchronizer which picks out frames and invokes a user-defined
callback function.
The synchronizer corrects for gain, carrier, and sample timing offsets
(channel impairments) in the complex baseband samples with a minimal
amount of pre-processing required by the user.

% FIGURE: framing:structure
\includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=16cm]{figures.pgf/framing_structure}


%
% SUBSECTION : 
%
\subsection{Setting up the Environment}
\label{tutorial:framing:environment}


%
% SUBSECTION : frame generator
%
\subsection{Creating the Frame Generator}
\label{tutorial:framing:framegen}
% talking points
%   * components to a frame
%       * header
%       * payload
%       * etc.
%   * options (m, beta)


%
% SUBSECTION : frame synchronizer
%
\subsection{Creating the Frame Synchronizer}
\label{tutorial:framing:framesync}
% talking points
%   * what framesync actually does
%       * gain control
%       * frame synchronization
%       * symbol timing recovery
%       * carrier phase recovery
%       * matched filtering
%       * demodulation
%       * frame decoding
%   * what is a callback function?

What is a callback function?
Put quite simply, a callback function is a function pointer that is
passed to the object so...

The {\tt framesync64} object has a callback function which has six
arguments and looks like this:
%
\begin{Verbatim}[fontsize=\small]
    int framesync64_callback(unsigned char * _header,
                             int _header_valid,
                             unsigned char * _payload,
                             int _payload_valid,
                             framesyncstats_s _stats,
                             void * _userdata);
\end{Verbatim}
%
The callback is typically defined to be {\tt static} and is passed to
the instance of {\tt framesync64} object when it is created.
%
\begin{description}
\item[{\tt \_header}]
    blah blah blah
\item[{\tt \_header\_valid}]
    blah blah blah
\item[{\tt \_payload}]
    blah blah blah
\item[{\tt \_payload\_valid}]
    blah blah blah
\item[{\tt \_stats}]
    blah blah blah
\item[{\tt \_userdata}]
    Remember that pointer you passed to the {\tt create()} method?
    That points is passed to the callback and can represent just about
    anything.
    Typically this is a pointer to another structure and is the method
    by which the decoded header and payload data are returned to the
    program outside of the callback.
\end{description}

Ok, so let's break down the frame synchronizer's operation.
When you receive samples at complex baseband...


%
% SUBSECTION : 
%
\subsection{Putting it All Together}
\label{tutorial:framing:xxx}
% talking points



%
% SUBSECTION : 
%
\subsection{Final Program}
\label{tutorial:framing:completed}

The final program is listed below,
and a copy of the source is located in the {\tt doc/tutorials/}
subdirectory.
%
\input{tutorials/framing_tutorial.c.tex}
%

% talking points:
%   * flexframe: advanced framing
%   * csma callbacks
%   * framesync properties

% extra credit
Under what circumstances does the synchronizer miss the frame?
For example, what is the minimum SNR level that is required to reliably
receive a frame?
the maximum carrier frequency offset?

% additional notes:
The ``random'' noise generated by the program will be seeded to the same
value every time the program is run.
A new seed can be initialized on the system's time (e.g. time of day) to
help generate new instances of random numbers each time the program is
run.
To do so, include the {\tt <time.h>} header to the top of your file and
add the following line to the beginning of your program:
%
\begin{Verbatim}[fontsize=\small]
    srand(time(NULL));
\end{Verbatim}
%

