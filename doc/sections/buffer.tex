% 
% MODULE : buffer
%
\section{buffer}
\label{module:buffer}

%
% gport
%
\subsection{gport}
\label{module:buffer:gport}
The {\tt gport} object implements a generic port to share data
between asynchronous threads.

There are two ways to access data: direct memory access and 
indirect (copied) memory acess.
Each has distinct advantages and distadvantages.
Depending upon your needs...
Regardless of which implementation you use, the model is equivalent:
a buffer of data (initially empty) is created.
The {\it producer} is the method in charge of writing to the buffer (or
``producing'' the data).
The {\it consumer} is the method in charge of reading the data from the buffer
(or ``consuming'' it).
The producer and consumer methods can exist on completely separate threads,
and do not need to be externally synchronized.
The {\tt gport} object synchronizes the data between the ports.

\subsubsection{Direct Memory Access}
Using {\tt gport} via direct memory access is a multi-step process, equivalent
for both the producer and consumer threads.
For the sake of simplicity, we will describe the process for writing data to
the port on the producer side...

\begin{enumerate}
\item the producer requests a lock on the port
\item once the request is serviced, the port returns a pointer to the array of
      data...
\item the producer writes its data at this location
\item the producer then unlocks the port, allowing the consumer thread to read
      data from it.
\item this process is repeated as necessary
\end{enumerate}

\input{listings/gport.direct.example.c.tex}

\subsubsection{Indirect/Copied Memory Access}
Indirect (or ``copied'') memory access...

\input{listings/gport.indirect.example.c.tex}

\subsubsection{Key differences between memory access modes}
While the direct memory access method provides a simpler interface--in the
sense that no external buffers are required--the user must take care in not
writing outside the bounds of the memory requested.
That is, if 256 samples are locked, only 256 values are available.
Writing more data will produce unexpected results.

Indirect memory acess requires the use of memory allocated externally to the
port.
The benefit is that both the internal producer and consumer methods will write
the data as it becomes available, and does not have to wait internally until
an entire block of the requested size is available.

It is important to stay consistent with the memory access mode used within a
thread, however mixed memory access modes can be used between threads on the
same port.
For example, the producer thread may use the direct memory access mode while
the consumer uses the indrect memory acess mode.

\subsubsection{Problem areas}
When using the direct memory access method, the size of the data request
during lock is limited by the size of the port.
[[race/lock conditions?]]

\subsection{{\tt window} buffer}
\label{module:buffer:window}
The {\tt window} object is used to implement a sliding window buffer.
It is essentially a first-in, first-out queue but with the constraint that a
fixed number of elements is always available, and the ability to read the
entire queue at once.
This is particularly useful for filtering objects which use time-domain
convolution of a fixed length to compute its outputs.
Unlike the {\tt gport} object, {\tt window} objects operate on a known data
type, e.g.
{\it float} ({\tt fwindow}), and
{\it float complex} ({\tt cfwindow}).
%{\it unsigned int} ({\tt uiwindow}).

The buffer has a fixed number of elements which are initially zeros.
Values may be pushed into the end of the buffer (into the ``right'' side)
using the {\tt push()} method, or written in blocks via {\tt write()}.
In both cases the oldest data samples are removed from the buffer (out of the
``left'' side).
When it is necessary to read the contents of the buffer, the {\tt read()}
method returns a pointer to its contents.
\liquid\ implements this shifting method in the same manner as a ring buffer,
and linearizes the data very efficiently, without performing any unnecessary
data memory copies.

\subsubsection{interface}
\label{module:buffer:window:interface}

\paragraph{{\tt window\_create()}}
creates a new window of a certain length.

\paragraph{{\tt window\_recreate()}}
Similar to the standard C library's {\tt realloc()}, {\tt recreate()} extends
an existing window...
If the size of the new window is larger than the old one, the old values are
pushed to the end

Here is an example:
\input{listings/window.example.c.tex}

