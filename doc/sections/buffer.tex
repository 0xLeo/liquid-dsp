% 
% MODULE : buffer
%

\newpage
\section{buffer}
\label{module:buffer}
The buffer module includes objects for storing, retrieving, and interfacing
with buffered data samples.


\subsection{{\tt window} buffer}
\label{module:buffer:window}
The {\tt window} object is used to implement a sliding window buffer.
It is essentially a first-in, first-out queue but with the constraint that a
fixed number of elements is always available, and the ability to read the
entire queue at once.
This is particularly useful for filtering objects which use time-domain
convolution of a fixed length to compute its outputs.
Unlike the {\tt gport} object, {\tt window} objects operate on a known data
type, e.g.
{\it float} ({\tt windowf}), and
{\it float complex} ({\tt windowcf}).
%{\it unsigned int} ({\tt uiwindow}).

The buffer has a fixed number of elements which are initially zeros.
Values may be pushed into the end of the buffer (into the ``right'' side)
using the {\tt push()} method, or written in blocks via {\tt write()}.
In both cases the oldest data samples are removed from the buffer (out of the
``left'' side).
When it is necessary to read the contents of the buffer, the {\tt read()}
method returns a pointer to its contents.
\liquid\ implements this shifting method in the same manner as a ring buffer,
and linearizes the data very efficiently, without performing any unnecessary
data memory copies.
Effectively, the window looks like:

\begin{centering}
\includegraphics[width=16cm]{figures.pgf/window}
\end{centering}

\subsubsection{Interface}
\label{module:buffer:window:interface}

\begin{description}
\item[{\tt window\_create()}]
    creates a new window of a certain length.
\item[{\tt window\_recreate()}]
    extends an existing window's size, similar to the standard C library's
    {\tt realloc()}.
    If the size of the new window is larger than the old one, the newest
    values are retained at the beginning of the buffer and the oldest values
    are truncated.
    % see \ref{listing:buffer:window}~line~23
    If the size of the new window is smaller than the old one, the oldest
    values are truncated.
    % see \ref{listing:buffer:window}~line~27
\item[{\tt window\_clear()}]
    clears the contents of the buffer by setting all internal values to zero.
\item[{\tt window\_index()}]
    retrieves the $n^{th}$ sample in the window.
    This is equivalent to first invoking {\tt read()} and then indexing on the
    resulting pointer, however the result is obtained much faster.
    Therefore invoking {\tt window\_index(w,0)} returns the {\em oldest} value
    in the window.
\item[{\tt window\_read()}]
    reads the contents of the window by returning a pointer to the aligned
    internal memory array.
    This method guarantees that the elements are linearized.
    This method should {\em only} be used for reading; writing values to the
    buffer has unknown results.
\item[{\tt window\_push()}]
    shifts a single sample into the right side of the window, pushing the
    oldest (left-most) sample out of the end.
    Unlike stacks, the {\tt window} object has no equivalent ``pop'' method,
    as values are retained in memory until they are overwritten.
\item[{\tt window\_write()}]
    writes a block of data to the window.
    Effectively, it is equivalent to pushing each sample one at a time, but
    executes much faster.
\end{description}

Here is an example demonstrating the basic functionality of the window object.
The comments show the internal state of the window after each function call as
if the window were a simple C array.
\input{listings/window.example.c.tex}

