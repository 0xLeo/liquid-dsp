% 
% MODULE : buffer
%
\section{buffer}
\label{module:buffer}
The buffer module includes objects for storing, retrieving, and interfacing
with buffered data samples.

%
% gport
%
\subsection{gport}
\label{module:buffer:gport}
The {\tt gport} object implements a generic port to share data between
asynchronous threads.
The port itself is really just a circular (ring) buffer containing a
mutually-exclusive locking mechanism to allow processes running on independent
threads to access its data.
Because no other modules rely on the {\tt gport} object and because it
requires the pthread library, it is likely to be removed from \liquid\ in the
near future and likely put into another library, e.g. {\em liquid-threads}.

There are two ways to access the data in the {\tt gport} object: direct memory
access and indirect (copied) memory acess, each with distinct advantages and
distadvantages.
Regardless of which interface you use, the model is equivalent:
a buffer of data (initially empty) is created.
The {\it producer} is the method in charge of writing to the buffer (or
``producing'' the data).
The {\it consumer} is the method in charge of reading the data from the buffer
(or ``consuming'' it).
The producer and consumer methods can exist on completely separate threads,
and do not need to be externally synchronized.
The {\tt gport} object synchronizes the data between the ports.

\subsubsection{Direct Memory Access}
Using {\tt gport} via direct memory access is a multi-step process, equivalent
for both the producer and consumer threads.
For the sake of simplicity, we will describe the process for writing data to
the port on the producer side; the consumer process is identical.
%
\begin{enumerate}
\item the producer requests a lock on the port of a certain number of samples.
\item once the request is serviced, the port returns a pointer to an array of
      data allocated internally by the port itself.
\item the producer writes its data at this location, not exceeding the
      original number of samples requested.
\item the producer then unlocks the port, indicating how many samples were
      actually written to the buffer.
      This allows the consumer thread to read data from the buffer.
\item this process is repeated as necessary.
\end{enumerate}
%
Listed below is a minimal example demonstrating the direct memory access
method for the {\tt gport} object.
%
\input{listings/gport.direct.example.c.tex}
%

\subsubsection{Indirect/Copied Memory Access}
Indirect (or ``copied'') memory access appears similar...

\input{listings/gport.indirect.example.c.tex}

\subsubsection{Key differences between memory access modes}
While the direct memory access method provides a simpler interface--in the
sense that no external buffers are required--the user must take care in not
writing outside the bounds of the memory requested.
That is, if 256 samples are locked, only 256 values are available.
Writing more data will produce unexpected results, and could likely result in
a segmentation fault.
Furthermore, the buffer must wait until the entire requested block is
available before returning.
This could potentially increase the amount of time that each process is
waiting on the port.
Additionally, if one requests too many samples on both the producer and
consumer sides, the port could wait forever.
For example, assume one initially creates a {\tt gport} with 100 elements and
the producer initially writes 30 samples.
Immediately following, the consumer requests a lock for 100 samples which
isn't serviced because only 30 are available.
Following that, the producer requests a lock for 100 samples which isn't
serviced because only 70 are available.
This is a deadlock condition where both threads are waiting for data, and
neither request will be serviced.
The solution to this problem is actually fairly simple; the port should be
initially created as the sum of maximum size of the producer's and consumer's
requests.
That is, if the producer will at most ever request a lock on 50 samples and
the consumer will at most request a lock of 70 samples, then the port should
be initially created with a buffer size of 120.
This guarantees that the deadlock condition will never occur.

Alternatively one may use the indirect memory access method which guarantees
that the deadlock condition will never occur, even if the buffer size is 1 and
the producer writes 1000 samples while the consumer reads 1000.
This is because both the internal producer and consumer methods will write
the data as it becomes available, and do not have to wait internally until an
entire block of the requested size is ready.
This is the benefit of using the indirect memory access interface of the
{\tt gport} object.
Indirect memory access, however, requires the use of memory allocated
externally to the port.

It is important to stay consistent with the memory access mode used within a
thread, however mixed memory access modes can be used between threads on the
same port.
For example, the producer thread may use the direct memory access mode while
the consumer uses the indrect memory acess mode.

\subsubsection{Interface}
\label{module:buffer:gport:interface}

\begin{description}
\item[{\tt gport\_create()}]
    creates a new {\tt gport} object with an internal buffer of a certain
    length.
\item[{\tt gport\_destroy()}]
    destroys a {\tt gport} object, signaling {\it end of message} to any
    connected ports.
    %calling {\tt gport\_signal\_eom()}
\item[{\tt gport\_producer\_lock()}]
    locks a requested number of samples for producing, returning a {\tt void}
    pointer to the locked data array directly.
    Invoking this method can be thought of as asking the port to allocate a
    certain number of samples for writing.
    Special care must be taken by the user not to write more elements to the
    buffer than were requested.
    This function is a blocking call and waits for the data to become
    available or an {\it end of message} signal to be received.
    The data are locked until {\tt gport\_producer\_unlock()} is invoked.
    The number of unlocked samples does not have to match but cannot exceed
    those which are locked.
\item[{\tt gport\_producer\_unlock()}]
    unlocks a requested number of samples from the port.
    Use in conjunction with {\tt gport\_producer\_lock()}.
    Invoking this method can be thought of as telling the port ``I have
    written $n$ samples to the buffer you gave me earlier; release them to the
    consumer for reading.''
    The number of samples written to the port cannot exceed the initial
    request (e.g. if you request a lock for 100 samples, you should never try
    to unlock more than 100).
    There is no internal error-checking to ensure this.
    Failure to comply could result in over-writing data internally, and
    corrupt the consumer side.
\item[{\tt gport\_produce()}]
    produces $n$ samples to the port from an external buffer.
    This method is a blocking call and waits for the requested data to become
    available or an {\it end of message} signal to be received.
\item[{\tt gport\_produce\_available()}]
    operates just like {\tt gport\_produce()} except will write as many
    samples as are available when the function is called.
    Invoking this method is like telling the buffer ``I have $n$ samples, so
    write as many as you can right now.''
    It will always wait for at least one sample to become available and blocks
    until this condition is met.
\item[{\tt gport\_consumer\_lock()}]
    locks a requested number of samples for consuming, returning a {\tt void}
    pointer to the locked data array directly.
    Invoking this method can be thought of as asking the port to wait for a
    certain number of samples to be read.
    Special care must be taken by the user not to read more elements to the
    buffer than were requested.
    This function is a blocking call and waits for enough samples to become
    available or an {\it end of message} signal to be received.
    The data will be locked until {\tt gport\_consumer\_unlock()} is invoked.
    The number of unlocked samples does not have to match but cannot exceed
    those which are locked.
\item[{\tt gport\_consumer\_unlock()}]
    unlocks a requested number of samples from the port.
    Use in conjunction with {\tt gport\_consumer\_lock()}.
    Invoking this method can be though of as telling the port ``I have read
    $n$ samples from the buffer you gave me earlier; release them to the
    producer for writing.''
    The number of samples read from the port cannot exceed the initial
    request (e.g. if you request a lock for 100 samples, you should never try
    to unlock more than 100).
\item[{\tt gport\_consume()}]
    consumes $n$ samples from the port and writes to an external buffer.
    This method is a blocking call and waits for the requested data to become
    available or an {\it end of message} signal to be received.
\item[{\tt gport\_consume\_available()}]
    operates just like {\tt gport\_consume()} except will read as many samples
    as are available when the function is called.
    Invoking this method is like telling the buffer ``I have a buffer of $n$
    samples, so write to it as many as you can right now.''
    It will always wait for at least one sample to become available and blocks
    until this condition is met.
\item[{\tt gport\_signal\_eom()}]
    signals {\it end of message} to any connected {\tt gport}.
    This tells the port to stop waiting for data (on both the producer and
    consumer side) and return.
    This method prevents lock conditions where, e.g., the producer is waiting
    for several samples to become available, but the consumer has finished its
    process.
    This method is normally invoked only during {\tt gport\_destroy()}.
\item[{\tt gport\_clear\_eom()}]
    ({\it untested})
    clears the {\it end of message} signal.
\end{description}


\subsubsection{Problem areas}
When using the direct memory access method, the size of the data request
during lock is limited by the size of the port.
[[race/lock conditions?]]

\subsection{{\tt window} buffer}
\label{module:buffer:window}
The {\tt window} object is used to implement a sliding window buffer.
It is essentially a first-in, first-out queue but with the constraint that a
fixed number of elements is always available, and the ability to read the
entire queue at once.
This is particularly useful for filtering objects which use time-domain
convolution of a fixed length to compute its outputs.
Unlike the {\tt gport} object, {\tt window} objects operate on a known data
type, e.g.
{\it float} ({\tt windowf}), and
{\it float complex} ({\tt windowcf}).
%{\it unsigned int} ({\tt uiwindow}).

The buffer has a fixed number of elements which are initially zeros.
Values may be pushed into the end of the buffer (into the ``right'' side)
using the {\tt push()} method, or written in blocks via {\tt write()}.
In both cases the oldest data samples are removed from the buffer (out of the
``left'' side).
When it is necessary to read the contents of the buffer, the {\tt read()}
method returns a pointer to its contents.
\liquid\ implements this shifting method in the same manner as a ring buffer,
and linearizes the data very efficiently, without performing any unnecessary
data memory copies.
Effectively, the window looks like:

\begin{centering}
\includegraphics[width=16cm]{figures.pgf/window}
\end{centering}

\subsubsection{Interface}
\label{module:buffer:window:interface}

\begin{description}
\item[{\tt window\_create()}]
    creates a new window of a certain length.
\item[{\tt window\_recreate()}]
    extends an existing window's size, similar to the standard C library's
    {\tt realloc()}.
    If the size of the new window is larger than the old one, the newest
    values are retained at the beginning of the buffer and the oldest values
    are truncated.
    % see \ref{listing:buffer:window}~line~23
    If the size of the new window is smaller than the old one, the oldest
    values are truncated.
    % see \ref{listing:buffer:window}~line~27
\item[{\tt window\_clear()}]
    clears the contents of the buffer by setting all internal values to zero.
\item[{\tt window\_index()}]
    retrieves the $n^{th}$ sample in the window.
    This is equivalent to first invoking {\tt read()} and then indexing on the
    resulting pointer, however the result is obtained much faster.
    Therefore invoking {\tt window\_index(w,0)} returns the {\em oldest} value
    in the window.
\item[{\tt window\_read()}]
    reads the contents of the window by returning a pointer to the aligned
    internal memory array.
    This method guarantees that the elements are linearized.
    This method should {\em only} be used for reading; writing values to the
    buffer has unknown results.
\item[{\tt window\_push()}]
    shifts a single sample into the right side of the window, pushing the
    oldest (left-most) sample out of the end.
    Unlike stacks, the {\tt window} object has no equivalent ``pop'' method,
    as values are retained in memory until they are overwritten.
\item[{\tt window\_write()}]
    writes a block of data to the window.
    Effectively, it is equivalent to pushing each sample one at a time, but
    executes much faster.
\end{description}

Here is an example demonstrating the basic functionality of the window object.
The comments show the internal state of the window after each function call as
if the window were a simple C array.
\input{listings/window.example.c.tex}

