% 
% MODULE : buffer
%
\section{buffer}
\label{module:buffer}

%
% gport
%
\subsection{gport}
\label{module:buffer:gport}
The {\tt gport} object implements a generic port to share data
between asynchronous threads.

There are two ways to access data: direct memory access and 
indirect (copied) memory acess.
Each has distinct advantages and distadvantages.
Depending upon your needs...
Regardless of which implementation you use, the model is equivalent:
a buffer of data (initially empty) is created.
The {\it producer} is the method in charge of writing to the buffer (or
``producing'' the data).
The {\it consumer} is the method in charge of reading the data from the buffer
(or ``consuming'' it).
The producer and consumer methods can exist on completely separate threads,
and do not need to be externally synchronized.
The {\tt gport} object synchronizes the data between the ports.

\subsubsection{Direct Memory Access}
Using {\tt gport} via direct memory access is a multi-step process, equivalent
for both the producer and consumer threads.
For the sake of simplicity, we will describe the process for writing data to
the port on the producer side...

\begin{enumerate}
\item the producer requests a lock on the port
\item once the request is serviced, the port returns a pointer to the array of
      data...
\item the producer writes its data at this location
\item the producer then unlocks the port, allowing the consumer thread to read
      data from it.
\item this process is repeated as necessary
\end{enumerate}

\input{listings/gport.direct.example.c.tex}

\subsubsection{Indirect/Copied Memory Access}
Indirect (or ``copied'') memory access...

\input{listings/gport.indirect.example.c.tex}

\subsubsection{Key differences between memory access modes}
While the direct memory access method provides a simpler interface--in the
sense that no external buffers are required--the user must take care in not
writing outside the bounds of the memory requested.
That is, if 256 samples are locked, only 256 values are available.
Writing more data will produce unexpected results.

Indirect memory acess requires the use of memory allocated externally to the
port.
The benefit is that both the internal producer and consumer methods will write
the data as it becomes available, and does not have to wait internally until
an entire block of the requested size is available.

It is important to stay consistent with the memory access mode used within a
thread, however mixed memory access modes can be used between threads on the
same port.
For example, the producer thread may use the direct memory access mode while
the consumer uses the indrect memory acess mode.

\subsubsection{Interface}
\label{module:buffer:gport:interface}

\begin{description}
\item[{\tt gport\_create()}]
    creates a new {\tt gport} object with an internal buffer of a certain
    length.
\item[{\tt gport\_destroy()}]
    destroys a {\tt gport} object, signaling {\it end of message} to any
    connected ports.
    %calling {\tt gport\_signal\_eom()}
\item[{\tt gport\_producer\_lock()}]
    locks a requested number of samples for producing, returning a {\tt void}
    pointer to the locked data array directly.
    Invoking this method can be thought of as asking the port to allocate a
    certain number of samples for writing.
    Special care must be taken by the user not to write more elements to the
    buffer than were requested.
    This function is a blocking call and waits for the data to become
    available or an {\it end of message} signal to be received.
    The data are locked until {\tt gport\_producer\_unlock()} is invoked.
    The number of unlocked samples does not have to match but cannot exceed
    those which are locked.
\item[{\tt gport\_producer\_unlock()}]
    unlocks a requested number of samples from the port.
    Use in conjunction with {\tt gport\_producer\_lock()}.
    Invoking this method can be thought of as telling the port ``I have
    written $n$ samples to the buffer you gave me earlier; release them to the
    consumer for reading.''
\item[{\tt gport\_produce()}]
    produces $n$ samples to the port from an external buffer.
    This method is a blocking call and waits for the requested data to become
    available or an {\it end of message} signal to be received.
\item[{\tt gport\_produce\_available()}]
    operates just like {\tt gport\_produce()} except will write as many
    samples as are available when the function is called.
    Invoking this method is like telling the buffer ``I have $n$ samples, so
    write as many as you can right now.''
    It will always wait for at least one sample to become available and blocks
    until this condition is met.
\item[{\tt gport\_consumer\_lock()}]
    locks a requested number of samples for consuming, returning a {\tt void}
    pointer to the locked data array directly.
    Invoking this method can be thought of as asking the port to wait for a
    certain number of samples to be read.
    Special care must be taken by the user not to read more elements to the
    buffer than were requested.
    This function is a blocking call and waits for enough samples to become
    available or an {\it end of message} signal to be received.
    The data will be locked until {\tt gport\_consumer\_unlock()} is invoked.
    The number of unlocked samples does not have to match but cannot exceed
    those which are locked.
\item[{\tt gport\_consumer\_unlock()}]
    unlocks a requested number of samples from the port.
    Use in conjunction with {\tt gport\_consumer\_lock()}.
    Invoking this method can be though of as telling the port ``I have read
    $n$ samples from the buffer you gave me earlier; release them to the
    producer for writing.''
\item[{\tt gport\_consume()}]
    consumes $n$ samples from the port and writes to an external buffer.
    This method is a blocking call and waits for the requested data to become
    available or an {\it end of message} signal to be received.
\item[{\tt gport\_consume\_available()}]
    operates just like {\tt gport\_consume()} except will read as many samples
    as are available when the function is called.
    Invoking this method is like telling the buffer ``I have a buffer of $n$
    samples, so write to it as many as you can right now.''
    It will always wait for at least one sample to become available and blocks
    until this condition is met.
\item[{\tt gport\_signal\_eom()}]
    signals {\it end of message} to any connected {\tt gport}.
    This tells the port to stop waiting for data (on both the producer and
    consumer side) and return.
    This method prevents lock conditions where, e.g., the producer is waiting
    for several samples to become available, but the consumer has finished its
    process.
    This method is normally invoked only during {\tt gport\_destroy()}.
\item[{\tt gport\_clear\_eom()}]
    ({\it untested})
    clears the {\it end of message} signal.
\end{description}


\subsubsection{Problem areas}
When using the direct memory access method, the size of the data request
during lock is limited by the size of the port.
[[race/lock conditions?]]

\subsection{{\tt window} buffer}
\label{module:buffer:window}
The {\tt window} object is used to implement a sliding window buffer.
It is essentially a first-in, first-out queue but with the constraint that a
fixed number of elements is always available, and the ability to read the
entire queue at once.
This is particularly useful for filtering objects which use time-domain
convolution of a fixed length to compute its outputs.
Unlike the {\tt gport} object, {\tt window} objects operate on a known data
type, e.g.
{\it float} ({\tt fwindow}), and
{\it float complex} ({\tt cfwindow}).
%{\it unsigned int} ({\tt uiwindow}).

The buffer has a fixed number of elements which are initially zeros.
Values may be pushed into the end of the buffer (into the ``right'' side)
using the {\tt push()} method, or written in blocks via {\tt write()}.
In both cases the oldest data samples are removed from the buffer (out of the
``left'' side).
When it is necessary to read the contents of the buffer, the {\tt read()}
method returns a pointer to its contents.
\liquid\ implements this shifting method in the same manner as a ring buffer,
and linearizes the data very efficiently, without performing any unnecessary
data memory copies.
Effectively, the window looks like:

\begin{centering}
\includegraphics[width=16cm]{figures.pgf/window}
\end{centering}

\subsubsection{Interface}
\label{module:buffer:window:interface}

\begin{description}
\item[{\tt window\_create()}]
creates a new window of a certain length.

\item[{\tt window\_recreate()}]
Similar to the standard C library's {\tt realloc()}, {\tt recreate()} extends
an existing window...
If the size of the new window is larger than the old one, the old values are
pushed to the end.

\item[{\tt window\_clear()}]
\item[{\tt window\_index()}]
\item[{\tt window\_read()}]
\item[{\tt window\_push()}]
\item[{\tt window\_write()}]
\end{description}

Here is an example:
\input{listings/window.example.c.tex}

