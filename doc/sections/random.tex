% 
% MODULE : random
%

\newpage
\section{random}
\label{module:random}
The random module in \liquid\ includes a comprehensive set of
random number generators useful for simulation of wireless
communications channels including the
uniform,
normal,
circular (complex) Gaussian,
Rice-$K$, and
Weibull distributions.
The random module also includes a data scrambler for ``whitening''
binary data sequences.

\subsection{Uniform}
\label{module:random:uniform}
%
\begin{equation}
\label{eqn:random:uniform:pdf}
    f_X(x) =
    \begin{cases}
        1 & \text{if $0 < x \le 1$} \\
        0 & \text{else}.
    \end{cases}
\end{equation}

\subsection{Normal}
\label{module:random:normal}
%
\begin{equation}
\label{eqn:random:normal:pdf}
    f_X(x;\sigma,\eta) =
        \frac{1}{\sigma \sqrt{2 \pi}}
        e^{-\left(x-\eta\right)^2/{2\sigma^2}}
\end{equation}
%
Computed using the Box-Muller method...
$U_1$ and $U_2$ are uniform random variables.
$X_1 = \sqrt{-2\ln(U_1)} \sin\left(2 \pi U_2\right)$,
$X_2 = \sqrt{-2\ln(U_1)} \cos\left(2 \pi U_2\right)$.
$X_1, X_2 \sim N(0,1)$.

\subsection{Weibull}
\label{module:random:weibull}
%
\begin{equation}
\label{eqn:random:weibull:pdf}
    f_X(x;\alpha,\beta,\gamma) =
    \begin{cases}
        \alpha(x-\gamma)^{\beta-1}
        e^{-(\alpha/\beta)(x-\gamma)^\beta} & \text{$x \ge \gamma$} \\
        0 &                                   \text{else}.
    \end{cases}
\end{equation}
%
Generated by inverting the Weibull cumulative ditribution function.
%
\begin{equation}
\label{eqn:random:weibull:cdf}
    F_X(x;\alpha,\beta,\gamma) =
    \begin{cases}
        1 - \exp\left\{
            -\left(\frac{x-\gamma}{\beta}\right)^\alpha
        \right\} &                            \text{$x \ge \gamma$} \\
        0 &                                   \text{else}.
    \end{cases}
\end{equation}
%
$X = \gamma + \beta\left[ \ln\left(1 - U\right) \right]^{1/\alpha}$
where $U \in (0,1)$ is a uniform random variable.

%\subsection{Gamma}

\subsection{Rice-$K$}
\label{module:random:ricek}
%
\begin{equation}
\label{eqn:random:ricek:pdf}
    f_R(r;K,\Omega) = 
        \frac{2(K+1)r}{\Omega}
        \exp\left\{-K-\frac{(K+1)r^2}{\Omega}\right\}
        I_0\left( 2r\sqrt{\frac{K(K+1)}{\Omega}} \right)
\end{equation}
%
where $\Omega=E\left\{R^2\right\}$ is the average signal power and $K$ is the
fading factor.
Generated from two independent normal random variables:
$s = \sqrt{\frac{\Omega K}{K+1}}$,
$\sigma = \sqrt{\frac{\Omega}{2(K+1)}}$.
$X_0 \sim N(0,\sigma)$,
$X_1 \sim N(s,\sigma)$,
$R = \sqrt{X_0^2 + X_1^2}$.


\subsection{Data scrambler}
\label{module:random:scramble}
Physical layer synchronization of received waveforms relies on independent and
identically distributed underlying data symbols.
If the message sequence, however, is too repetitive
(such as '{\tt 00000....}' or '{\tt 11001100....}')
and the modulation scheme is BPSK, the synchronizer probably won't be able to
recover the symbol timing because adjacent symbols are too similar.
This is a result of spectral correlation introduced which can prevent physical
layer synchronization techniques from tracking or even acquisition.
Having said that, certain patterns {\em are} beneficial to synchronization and
actually help the receiver track to the incoming signal, however these are
usually only introduced as a preamble to a frame or packet where the receiver
knows what to expect.
It is therefore imperative to increase the short-term entropy of the
underlying data to prevent the receiver from losing its lock on the signal.
The data scrambler routine attempts to ``whiten'' the data sequence with a bit
mask in order to achieve maximum entropy.

\subsubsection{interface}
The data scrambler has two methods, described here:
\begin{description}
\item[{\tt scramble\_data()}]
    takes an input sequence of data and scrambles the bits by applying a
    periodic mask.
    The first argument is a pointer to the input data array; the second
    argument is its length (number of bytes).
\item[{\tt unscramble\_data()}]
    takes an input sequence of data and unscrambles the bits by applying the
    reverse mask applied by {\tt scramble\_data()}.
    Just like {\tt scramble\_data()}, the first argument is a pointer to the
    input data array; the second argument is its length (number of bytes).
\end{description}

See {\tt examples/scramble\_example.c} for a full example of the interface.

