%
% introduction
%

\newpage
\section{Background and History}

\liquid\ is a free and open-source digital signal processing (DSP) library
designed specifically for software-defined radios on embedded platforms.
The aim is to provide a lightweight DSP library that does not rely on a myriad
of external dependencies or proprietary and otherwise cumbersome frameworks.
%
All signal processing elements are designed to be flexible, scalable, and
dynamic, including filters, filter design, oscillators, modems, synchronizers,
and complex mathematical operations.
The source for \liquid\ is written entirely in C so that it can be
compiled quickly with a low memory footprint.

\liquid\ was created by J. Gaeddert out of necessity to perform complex
digital signal processing algorithms on embedded devices
without relying on dealing
with proprietary and otherwise cumbersome frameworks.
This was a critical step in his PhD thesis to adapt DSP algorithms in
cognitive dynamic-spectrum radios to optimally manage finite radio resources.


% Key points
%   * open-source software-defined radio DSP algorithms
%   * minimal dependence on external libraries
%   * portable to embedded platforms
%   * flexible configuration
%   * targets cognitive radios and enabling technologies through
%     flexible algorithmic development
%
% Features
%   * automatic test scripts for validation and accuracy
%   * benchmark tool for estimating computational speed on your machine
%

\section{Quick Start Guide}
\label{section:quickstart}
The library can be easily built from source and is available from
several places.
The two most typical means of distribution are a compressed archive
(a {\em tarball}) and cloning the source repository.
Tarballs are generated with each stable release and are recommended for
users not expecting bleeding edge development.
Users wanting the very latest version (in addition to every other
version) should clone the \liquid\ {\tt git} repository.

\subsection{Building from an archive}
\label{section:quickstart:build_from_tarball}
\label{xxx}
Download the compressed archive {\tt liquid-dsp-v.v.v.tar.gz} to your
local machine where {\tt v.v.v} denotes the version of the release.
% Check the validity of the tarball using MD5...
%
% generate:
%   $ md5sum liquid-dsp-v.v.v.tar.gz > liquid-dsp.md5
%
% check:
%   $ md5sum --check liquid-dsp.md5
%
% You should see a message verifying the file:
%   liquid-dsp-v.v.v.tar.gz: OK
%
% If it fails, do no unpack.
Unpack the tarball
%
\begin{verbatim}
    $ tar -xvf liquid-dsp-v.v.v.tar.gz
\end{verbatim}
%
Move into the directory and run the configure script and make the
library.
%
\begin{verbatim}
    $ cd liquid-dsp-v.v.v
    $ ./configure
    $ make
    # make install
\end{verbatim}

\subsection{Building from the {\tt git} repository}
\label{section:quickstart:build_from_git}
\liquid\ uses {\tt git} \cite{git:web} for version control, a free and
open-source.
The benefits of {\tt git} over many other version control systems are
numerous and the list is too long to give here;
however one of the most important aspects is that each clone holds a
copy of the entire repository with a complete history and record of each
revision.
The main repository for \liquid\ is hosted online by {\em github}
\cite{github:web} and can be cloned on your local machine via
%
\begin{verbatim}
    $ git clone git://github.com/jgaeddert/liquid-dsp.git
\end{verbatim}
%
Move into the directory and build as before with the archive,
but with the additional bootstrapping step:
%
\begin{verbatim}
    $ cd liquid-dsp.git
    $ ./reconf
    $ ./configure
    $ make
    # make install
\end{verbatim}

\subsection{Additional targets}
\label{section:quickstart:additional_targets}
%
You may also want to build and run the optional validation program
(see Section~\ref{section:installation:targets:autotests}) via
\begin{verbatim}
    $ make check
\end{verbatim}
and the benchmarking tool
(see Section~\ref{section:installation:targets:benchmarks})
\begin{verbatim}
    $ make bench
\end{verbatim}
%
A comprehensive list of signal processing examples are given in the
{\tt examples} directory and can be built as
\begin{verbatim}
    $ make examples
\end{verbatim}
%
Each example can be built individually by directly targeting its binary
(e.g. {\tt make examples/cvsd\_example}).

\section{Tutorial}
\label{section:tutorial}
Most of \liquid's signal processing elements are C structures which
retain the object's parameters, state, and other useful information.
The naming convention is
{\tt basename\_xxxt\_method} where
{\tt basename} is the base object name (e.g. {\tt interp}),
{\tt xxxt} is the type definition, and
{\tt method} is the object method.
The type definition describes respective output, internal, and input type.
Types are usually {\tt f} to denote standard 32-bit {\it floating point}
precision values and can either be represented as {\tt r} (real) or {\tt c}
(complex).
For example, a {\tt dotprod} (vector dot product) object with complex input
and output types but real internal coefficients operating on 32-bit
floating-point precision values is {\tt dotprod\_crcf}.

Most objects have at least four standard methods:
{\tt create()},
{\tt destroy()},
{\tt print()},
and
{\tt execute()}.
Certain objects also implement a {\tt recreate()} method which operates
similar to that of {\tt realloc()} in C and are used to restructure or
reconfigure an object without completely destroying it and creating it again.
Typically, the user will create the signal processing object independent of
the external (user-defined) data array.
The object will manage its own memory until its {\tt destroy()} method is
invoked.
A few points to note:
\begin{enumerate}
\item The object is only used to maintain the state of the signal processing
      algorithm.
      For example, a finite impulse response filter
      (Section~\ref{module:filter:firfilt}) needs to retain the filter
      coefficients and a buffer of input samples.
      Certain algorithms which do not retain information (those which are
      memoryless) do not use objects.
      For example, {\tt design\_rrc\_filter()}
      (Section~\ref{module:filter:firdes:rrcos})
      calculates the coefficients of a root raised-cosine filter, a processing
      algorithm which does not need to maintain a state after its completion.
\item While the objects do retain internal memory, they typically operate on
      external user-defined arrays.
      As such, it is strictly up to the user to manage his/her own memory.
      Shared pointers are a great way to cause memory leaks, double-free bugs,
      and severe headaches.
%\item ...
\end{enumerate}

\section{Learning by example}
While this document contains numerous examples listed in the text, they are
typically condensed to demonstrate only the interface.
The {\tt examples/} subdirectory includes more extensive demonstrations and
numerous examples for all the signal processing components.
Many of these examples write an output file which can be read by
octave~\cite{octave:web} to display the results.
For a brief description of each of these examples, see {\tt examples/README}.

\subsection{Why C?}
A commonly asked question is ``why C and not C++?''
The answer is simple: {\em portability}.
Our aim is to provide a lightweight DSP library for software-defined radio
that does not rely on a myriad of dependencies.
While C++ is a fine language for many purposes (and theoretically runs just as
fast as C), it is not as portable to embedded platforms as C.
Furthermore, the majority of functions simply perform complex operations on a
data sequence and do not require a high-level object-oriented programming
interface.
The importance in object-oriented programming is the techniques used, not the
languages describing it.

While a number of signal processing elements in \liquid\ use structures, these
are simply to save the internal state of the object.
For instance, a {\tt firfilt\_crcf} (finite impulse response filter) object
is just a structure which contains--among other things--the filter taps
(coefficients) and an input buffer.
This simplifies the interface to the user; one only needs to ``push'' elements
into the filter's internal buffer and ``execute'' the dot product when
desired.
This could also be accomplished with classes, a construct specific to C++ and
other high-level object-oriented programming languages, however,
for the most part, C++ polymorphic data types and abstract base classes are
unnecessary for basic signal processing, and primarily just serve to reduce
the code base of a project.
Furthermore, while C++ templates can certainly be useful for library development,
their benefits are of limited use to signal processing and can be circumvented
through the use of pre-processor macros at the gain of targeting more embedded
processors.
Under the hood, the C++ compiler's pre-processor expands templates and classes
before actually compiling the source anyway, so in this sense they are
equivalent to the second-order macros used in \liquid.

The C programming language has a rich history in system programming--
specifically targeting embedded applications--and is the basis behind many
well-known projects including the linux kernel and the python programming
language.
Having said this, high-level frameworks and graphical interfaces are much more
suited to be written in C++ and will beat an implementation in C any day,
but lie far outside the scope of this project.

\subsection{Data Types}
The majority of signal processing for SDR is performed at complex baseband.
Complex numbers are handled in \liquid\ by defining data type
{\tt liquid\_float\_complex} which is binary compatible with the standard
C math type {\tt float complex} and C++ type {\tt std::complex<float>}.

Fixed-point data types are defined in the \liquidfpm\ library (see XXX).

\subsection{Building/Linking with C++}
Although \liquid\ is written in C, it can be seamlessly compiled and linked
with C++ source files.
Here is an example:
\input{listings/nco.c++.tex}

%\section{Complex Baseband}
%\label{section:complex_baseband}

