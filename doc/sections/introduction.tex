%
% introduction
%

\liquid\ is a free and open-source digital signal processing (DSP) library
designed specifically for software-defined radios on embedded platforms.
The aim is to provide a lightweight DSP library that does not rely on a myriad
of external dependencies or proprietary and otherwise cumbersome frameworks.
All signal processing elements are designed to be flexible, scalable, and
dynamic, including filters, filter design, oscillators, modems, synchronizers,
and complex mathematical operations.

\section{Key points}
\begin{itemize}
\item open-source software-defined radio DSP algorithms
\item minimal dependence on external libraries
\item portable to embedded platforms
\item flexible configuration
\item targets cognitive radios and enabling technologies through
      flexible algorithmic development
\end{itemize}

\subsection{Features}
\begin{itemize}
\item automatic test scripts for validation and accuracy
\item benchmark tool for estimating computational speed on your machine
\end{itemize}


\section{Quick Start Guide}
To build:
\begin{verbatim}
    $ cd /path/to/liquid/
    $ ./reconf
    $ ./configure
    $ make
    # make install
\end{verbatim}
You may also want to build and run the optional validation program
(see Section~\ref{ch:installation:targets:autotests}) via
\begin{verbatim}
    $ make check
\end{verbatim}
and the benchmarking tool
(see Section~\ref{ch:installation:targets:benchmarks})
\begin{verbatim}
    $ make bench
\end{verbatim}

\section{Tutorial}
Most of \liquid's signal processing elements are C structures which
retain the object's parameters, state, and other useful information.
The naming convention is
{\tt basename\_xxxt\_method} where
{\tt basename} is the base object name (e.g. {\tt interp}),
{\tt xxxt} is the type definition, and
{\tt method} is the object method.
The type definition describes respective output, internal, and input type.
Types are usually {\tt f} to denote standard 32-bit {\it floating point}
precision values and can either be represented as {\tt r} (real) or {\tt c}
(complex).
For example, a {\tt dotprod} (vector dot product) object with complex input
and output types but real internal coefficients operating on 32-bit
floating-point precision values is {\tt dotprod\_crcf}.

Most objects have at least four standard methods:
{\tt create()},
{\tt destroy()},
{\tt print()},
and
{\tt execute()}.
Certain objects also implement a {\tt recreate()} method which operates
similar to that of {\tt realloc()} in C and are used to restructure or
reconfigure an object without completely destroying it and creating it again.
Typically, the user will create the signal processing object independent of
the external (user-defined) data array.
The object will manage its own memory until its {\tt destroy()} method is
invoked.
A few points to note:
\begin{enumerate}
\item The object is only used to maintain the state of the signal processing
      algorithm.
      For example, a finite impulse response filter
      (Section~\ref{module:filter:firfilt}) needs to retain the filter
      coefficients and a buffer of input samples.
      Certain algorithms which do not retain information (those which are
      memoryless) do not use objects.
      For example, {\tt design\_rrc\_filter()}
      (Section~\ref{module:filter:firdes:rrcos})
      calculates the coefficients of a root raised-cosine filter, a processing
      algorithm which does not need to maintain a state after its completion.
\item While the objects do retain internal memory, they typically operate on
      external user-defined arrays.
      As such, it is strictly up to the user to manage his/her own memory.
      Shared pointers are a great way to cause memory leaks, double-free bugs,
      and severe headaches.
%\item ...
\end{enumerate}

\section{Learning by example}
While this document contains numerous examples listed in the text, they are
typically condensed to demonstrate only the interface.
The {\tt examples/} subdirectory includes more extensive demonstrations and
numerous examples for all the signal processing components.
Many of these examples write an output file which can be read by
octave~\cite{octave:web} to display the results.
For a brief description of each of these examples, see {\tt examples/README}.

\subsection{Why C?}
A commonly asked question is ``why C and not C++?''
The answer is simple: {\em portability}.
Our aim is to provide a lightweight DSP library for software-defined radio
that does not rely on a myriad of dependencies.
While C++ is a fine language for many purposes (and theoretically runs just as
fast as C), it is not as portable to embedded platforms as C.
Furthermore, the majority of functions simply perform complex operations on a
data sequence and do not require a high-level object-oriented programming
interface.
The importance in object-oriented programming is the techniques used, not the
languages describing it.

While a number of signal processing elements in \liquid\ use structures, these
are simply to save the internal state of the object.
For instance, a {\tt firfilt\_crcf} (finite impulse response filter) object
is just a structure which contains--among other things--the filter taps
(coefficients) and an input buffer.
This simplifies the interface to the user; one only needs to ``push'' elements
into the filter's internal buffer and ``execute'' the dot product when
desired.
This could also be accomplished with classes, a construct specific to C++ and
other high-level object-oriented programming languages, however,
for the most part, C++ polymorphic data types and abstract base classes are
unnecessary for basic signal processing, and primarily just serve to reduce
the code base of a project.
Furthermore, while C++ templates can certainly be useful for library development,
their benefits are of limited use to signal processing and can be circumvented
through the use of pre-processor macros at the gain of targeting more embedded
processors.
Under the hood, the C++ compiler's pre-processor expands templates and classes
before actually compiling the source anyway, so in this sense they are
equivalent to the second-order macros used in \liquid.

The C programming language has a rich history in system programming--
specifically targeting embedded applications--and is the basis behind many
well-known projects including the linux kernel and the python programming
language.
Having said this, high-level frameworks and graphical interfaces are much more
suited to be written in C++ and will beat an implementation in C any day,
but lie far outside the scope of this project.

\subsection{Data Types}
The majority of signal processing for SDR is performed at complex baseband.
Complex numbers are handled in \liquid\ by defining data type
{\tt liquid\_float\_complex} which is binary compatible with the standard
C math type {\tt float complex} and C++ type {\tt std::complex<float>}.

Fixed-point data types are defined in the \liquidfpm\ library (see XXX).

\subsection{Building/Linking with C++}
Although \liquid\ is written in C, it can be seamlessly compiled and linked
with C++ source files.
Here is an example:
\input{listings/nco.c++.tex}

\section{History}
\liquid\ was created by J. Gaeddert out of necessity to perform complex
digital signal processing algorithms on embedded devices
without relying on dealing
with proprietary and otherwise cumbersome frameworks.
This was a critical step in his PhD thesis to adapt DSP algorithms in
cognitive dynamic-spectrum radios to optimally manage finite radio resources.
Was he successful?
Put it this way: at the time this document was written he still has not
graduated.\footnote{Come back in a year and ask again... {\em sigh}}

