% 
% MODULE : agc (automatic gain control)
%

\section{agc (automatic gain control)}
\label{module:agc}
Normalizing an incoming signal level before further processing is a critical
step for many wireless communications protocols, particularly in digital
modulation schemes which encode information in the signal amplitude (e.g. see
{\tt MOD\_QAM}, section~\ref{module:modem:digital}).
Furthermore, loop filters for tracking carrier and symbol timing are highly
sensitive to signal levels.
For these reasons and more does gain control play a crucial role in SDR.
The ideal AGC has a transfer function as in
figure~\ref{fig:module:agc:transfer_function}.
When the input signal level is low, the AGC is disabled and the output is a
linear function of the input.
When the input level reaches a lower threshold, $e_0$, the AGC becomes active
and the output level is maintained at the target, $\bar{e}$, until the input
reaches its upper limit, $e_1$.
The AGC is disabled at this point, and the output level is again a linear
function of the input.

\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=10cm]{figures.pgf/agc_transfer_function}
\caption{Ideal AGC transfer function}
\label{fig:module:agc:transfer_function}
\end{figure}

\liquid\ implements automatic gain controlling with the {\tt agc\_xxxt}
family of objects.
The goal is to estimate the gain required to force a signal to have a specific
target energy, $\bar{e}$.
Operating one sample at a time, the {\tt agc} object makes an estimate
$\hat{e}$ of the signal energy and updates the internal gain $g$,
applying it to the input to produce an output with the target energy.
The gain estimate is updated by way of an open loop filter whose bandwidth
determines the update rate of the AGC.

Given an input signal
$\vec{x} = [\vec{x}_0, \vec{x}_1, \ldots, \vec{x}_{N-1}]$,
its energy is computed as its $L_2$ norm over the entire sequence, viz.
\[
    E\{ \|\vec{x}\| \} = 
        \sqrt{
            \sum\limits_{k=0}^{N-1} {\|\vec{x}_k^2\|}
        }
\]
%For a continuous signal, this is
%\[
%    E\{\| x(t) \|\} =
%        \sqrt{
%            \frac{1}{T}\int_0^{T} { x^2(t) dt }
%        }
%\]
For received communications signals, however, the goal is to adjust to the
gain of the receiver relative to the slowly-varying amplitude of the incoming
receiver due to shadowing, path loss, etc.
%Furthermore, it is impractical to estimate the signal energy of an entire
%vector for each sample of input.
Therefore it is necessary to make an estimate of the instantaneous signal
energy, one sample at at time.
The time-average signal energy may be estimated at time $k$ as a partial
feedback sum of the previous estimate
\begin{equation}
\label{eq:module:agc:ehat}
    \hat{e}_k =
        \Bigl[
            \zeta\|\vec{x}_k\|^2 + (1-\zeta)\hat{e}_{k-1}^2
        \Bigr]^{1/2}
\end{equation}
where $\| \vec{x}_k \|^2$ is the instantaneous signal energy estimate at time
$k$ and $\zeta$ is the smoothing factor, commensurate of the filter bandwidth%
\footnote{This smoothing factor is necessary to help prevent wild fluctuations
in $\hat{e}_k$ which can occur if the input signal's instantaneous amplitude
has significant variation, such as in digitally-modulated signals.}
The choice of $\zeta$ affects the both the amount of noise allowed in the
signal energy estimate, and its speed of adjustment to the dynamics of
$vec{x}$.
%A smaller value of $\zeta$ decreases the...
\liquid\ uses an internal fixed value of $0.1$ for $\zeta$.

Now that the signal energy has been estimated, all that remains is to adjust
the gain of the receiver accordingly.
\liquid\ implements three types of open-loop gain controls, described in the
next three sections.
Each uses a common loop filter parameter for a given bandwidth, $w$, as
\[
    \alpha = \sqrt{w}
\]
Notice the similarity of $\alpha$ in estimating the gain to $\zeta$ in
(\ref{eq:module:agc:ehat}) to estimating the signal energy.
If you are unsure which type of AGC to use, we recommend
{\tt LIQUID\_AGC\_DEFAULT} as a good all-around control.
The reason for three is to allow flexibility in the receiver as
each control mechanism has slight performance differences and might require
fewer clock clycles, depending upon the architecture of the target platform
and the precision of the data type used.

\subsection{{\tt LIQUID\_AGC\_DEFAULT}}
The default {\tt agc} type is a... 
%
The instantaneous signal energy estimate is given in
(\ref{eq:module:agc:ehat}).
In order to achieve a target energy $\bar{e}$, the instantaneous ideal gain is
thereefore the ratio of the target to the estimated energy vectors,
\[
    \hat{g}_k = \bar{e} / \hat{e}_k
\]
Rather than applying the gain directly to the input signal it is first
filtered as
\[
    g_k = \alpha \hat{g}_k + (1-\alpha) g_{k-1}
\]
where again $\alpha = \sqrt{w}$ is the smoothing factor of the gain estimate
and controls the attack and release time the {\tt agc} object has on an input
signal.
Notice the similarity the above equation has to (\ref{eq:module:agc:ehat}).

\subsection{{\tt LIQUID\_AGC\_LOG}}
As in the default case, the log {\tt agc} type makes an estimate of the
instantaneous signal energy estimate as given by (\ref{eq:module:agc:ehat})
and an estimate of the instantaneous gain as
$\hat{g}_k = \bar{e} / \hat{e}_k$.
The loop control, however, operates on the log of the gain difference rather
than its linear component.
Therefore the gain error at time $k$ can be represented as
\[
    \gamma_k = \ln\bigl( \hat{g}_k / g_{k-1} \bigr)
\]
The {\tt agc} then updates its gain estimate according to the magnitude of the
error, viz.
\[
    %g_k = g_{k-1} e^{ \alpha \gamma_k }
    g_k = g_{k-1} \exp\bigl\{ \alpha \gamma_k \bigr\}
\]
Notice that when $\gamma_k=0$, the gain is not updated
(i.e. $\hat{g}_k = \hat{g}_{k-1}$).

\subsection{{\tt LIQUID\_AGC\_EXP}}
The exponential gain update method does not...
The instantaneous output energy is
\[
    \|\vec{y}_k\| = g_{k-1}\|\vec{x}_k\|
\]
and the gain error is
\[
    \gamma_k = \| \vec{y}_k\| - \bar{e}
\]
The gain estimate is updated proportional to the gain error, viz
\[
    g_k =
        g_{k-1} \left(1 -
         \frac{
            \gamma_k \sqrt{\alpha}
        }{
            \text{argmax}\left\{\bar{e}, \|\vec{y}_k\|\right\}
        }
    \right)
\]
The multiplier in to the right of the above equation is always positive
and proportional to the gain error.
Notice that when the error is zero ($\| \vec{y}_k \| = \bar{e}$),
$g_k = g_{k-1}$.


\subsection{Locking}
The {\tt agc} module permits the gain to be locked when, for example, the
header of a packet is received.
This is useful for effectively switching the AGC on and off during short,
burt-mode packet transmissions, particularly when the signal has a high-order
digital amplitude-modulation (e.g. 64-QAM) and the AGC could potentially
corrupt the data.
When the {\tt agc} object is locked, the internal gain control is not updated,
and the internal gain at the time of locking is applied directly to the output
signal.
%
Locking and unlocking is accomplished with the
{\tt agc\_crcf\_lock()} and
{\tt agc\_crcf\_unlock()} methods, respectively.

\subsection{Squelch}
The {\tt agc} module contains internal squelch control to allow the
controlling unit the ability to disable signal processing when the signal
level is too low.
In traditional radio design, the squelch circuit suppressed the
output of a receiver when the signal strength would fall below a certain level,
primarily used to disable annoying static due to noise when no other operators
were transmitting.
Having said that, the squelch control in \liquid\ is actually somewhat of a
misnomer as it doesn't actually control the AGC, but rather just monitors the
dynamics of the signal level and returns its status to the controlling unit.
The squelch control follows six states
(enabled, rising edge trigger, signal high, falling edge trigger,
signal low, and timeout)
as depicted in
Figure~\ref{fig:module:agc:squelch} and
Table~\ref{tab:module:agc:squelch_codes}.
These states give the user flexibility in programming networks where packets
are transmitted in short bursts and the receiver needs to synchronize quickly.
The status of the squelch control is retrieved via the
{\tt agc\_crcf\_squelch\_get\_status()} method.

The typical control cycle for the AGC squelch is depicted in
Figure~\ref{fig:module:agc:squelch}.
Initially, squelch is enabled (code {\tt 0}) as the signal has been low for
quite some time.
When the beginning of a packet is received, the RSSI increases beyond the
squelch threshold (code {\tt 1}).
All subsequent samples above this threshold return a ``signal high'' status
(code {\tt 2}).
Once the signal level falls below the threshold, the squelch returns a
``falling edge trigger'' status (code {\tt 3}).
All subsequent samples below the threshold until timing out return a ``signal
low'' status (code {\tt 4}).
When the signal has been low for a sufficient period of time (defined by the
user), the squelch will return a ``timeout'' status (code {\tt 5}).
All subsequent samples below the threshold will return a ``squelch enabled''
status.

\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=16cm]{figures.pgf/agc_squelch}
\caption{{\tt agc\_crcf} squelch}
\label{fig:module:agc:squelch}
\end{figure}


% ------------ TABLE: AGC SQUELCH CODES ------------
\begin{table}[!ht]
\caption{{\tt agc} squelch codes}
\label{tab:module:agc:squelch_codes}
\centering
\begin{tabular*}{0.95\textwidth}{@{\extracolsep{\fill}}lll}

\hline\hline \\[-6pt]
{\bf code} & {\bf id} & {\bf description} \\[6pt]
\hline \\[-6pt]
{\tt 0} & {\tt LIQUID\_AGC\_SQUELCH\_ENABLED}    & squelch enabled \\
{\tt 1} & {\tt LIQUID\_AGC\_SQUELCH\_RISE}       & rising edge trigger \\
{\tt 2} & {\tt LIQUID\_AGC\_SQUELCH\_SIGNALHI}   & signal level high \\
{\tt 3} & {\tt LIQUID\_AGC\_SQUELCH\_FALL}       & falling edge trigger \\
{\tt 4} & {\tt LIQUID\_AGC\_SQUELCH\_SIGNALLO}   & signal level low, but no timeout \\
{\tt 5} & {\tt LIQUID\_AGC\_SQUELCH\_TIMEOUT}    & signal level low, timeout \\ \\[-6pt]

\hline\hline
\end{tabular*}
\end{table}%
% ------------------------


\subsubsection{methodology}
The reason for all six states (as opposed to just ``squelch on'' and ``squelch
off'') are to allow for the AGC to adjust to complex signal dynamics.
The default operation for the AGC is to {\it disable} the squelch.
For example if the AGC squelch control is in ``signal low'' mode
(state {\tt 4}) and the signal increases above the threshold before timeout,
the AGC will move back to the ``signal high'' mode (state {\tt 2}).
This is particularly useful for weak signals whose received signal strength is
hovering around the squelch threshold; it would be undesireable for the AGC to
enable the squelch in the middle of receiving a packet!

\subsubsection{auto-squelch}
The AGC module also allows for an auto-squelch mechanism which attempts to
track the signal threshold to the noise floor of the receiver.
This is accomplished by monitoring the signal level when squelch is enabled.
The auto-squelch mechanism has a 4dB headroom; if the signal level drops below
4dB beneath the squelch threshold, the threshold will be decremented.
This is useful for receiving weak signals slightly above the noise floor,
particularly when the exact noise floor is not known or varies slightly over
time.
Auto-squelch is enabled/disabled using the
{\tt agc\_crcf\_squelch\_enable\_auto()} and 
{\tt agc\_crcf\_squelch\_disable\_auto()} methods respectively.

\subsection{Usage}
Basic usage:
\input{listings/agc.example.c.tex}

\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=16cm]{figures.gen/agc_transient}
\caption{{\tt agc\_crcf} transient response}
\label{fig:module:agc:transient}
\end{figure}


