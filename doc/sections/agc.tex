% 
% MODULE : agc (automatic gain control)
%

\section{agc (automatic gain control)}
\label{module:agc}
Normalizing an incoming signal level before further processing is a critical
step for many wireless communications protocols, particularly in digital
modulation schemes which encode information in the signal amplitude (e.g. see
{\tt MOD\_QAM}, section~\ref{module:modem:digital}).
Furthermore, loop filters for tracking carrier and symbol timing are highly
sensitive to signal levels.
For these reasons and more does gain control play a crucial role in SDR.

\liquid\ implements automatic gain controlling with the {\tt agc\_xxxt}
family of objects.
The goal is to estimate the gain required to force a signal to have a specific
target energy, $\bar{e}$.
Operating one sample at a time, the {\tt agc} object makes an estimate
$\hat{e}$ of the signal energy and updates the internal gain $\hat{g}$,
applying it to the input to produce an output with the target energy.
The gain estimate is updated by way of an open loop filter whose bandwidth
determines the update rate of the AGC.

\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=10cm]{figures.pgf/agc_transfer_function}
\caption{Ideal AGC transfer function}
\label{fig:module:agc:transfer_function}
\end{figure}


Loop filter coefficients for a bandwidth $w$,
\[  \alpha = \sqrt{w}   \]
\[  \beta = 1 - \alpha  \]

\subsection{{\tt LIQUID\_AGC\_DEFAULT}}
The default {\tt agc} type is a... For a given input sample $x$ at time $n$,
the filtered signal energy estimate $\hat{e}$ is
\[  q(n) = \zeta\|x\|^2 + (1-\zeta)q(n-1)   \]
\[  \hat{e}(n) = \sqrt{q(n)}                \]
where $q(0)=0$ and $\zeta=0.1$ is a smoothing factor.%
\footnote{This smoothing factor is necessary to help prevent wild fluctuations
in $\hat{e}(n)$ which can occur if the input signal's instantaneous amplitude
has significant variation.}
The instantaneous ideal gain is
\[
    \bar{g}(n) = \bar{e}(n) / \hat{e}(n)
\]
and the filtered gain estimate is
\[
    \hat{g}(n+1) = \beta \hat{g}(n) + \alpha \bar{g}(n)
\]

\subsection{{\tt LIQUID\_AGC\_LOG}}
As in the default case, the log {\tt agc} type makes an estimate of the
instantaneous gain,
\[
    \bar{g}(n) = \bar{e}(n) / \hat{e}(n)
\]
however the loop control operates on the log of the gain error, viz
\[
    \gamma(n) = \ln\bigl( \bar{g}(n) / \hat{g}(n) \bigr)
\]
The {\tt agc} then updates its gain estimate according to the magnitude of the
error.
\[
    \hat{g}(n+1) = \hat{g}(n) e^{ \alpha \gamma(n) }
\]
Notice that when $\gamma(n)=0$, the gain is not updated
(i.e. $\hat{g}(n+1) = \hat{g}(n)$).


\subsection{{\tt LIQUID\_AGC\_EXP}}
The exponential gain update method does not...
The instantaneous output energy is
\[  \|y(n)\| = \hat{g}(n)\|x(n)\|      \]
and the gain error is
\[
    \gamma(n) = \|y(n)\| - \bar{e}
\]
The gain estimate is updated proportional to the gain error, viz
\[
    \hat{g}(n+1) =
        \hat{g}(n) \left(1 -
         \frac{
            \gamma(n)\sqrt{\alpha}
        }{
            \text{argmax}\left\{\bar{e}(n),\|y(n)\|\right\}
        }
    \right)
\]
The multiplier in to the right of the above equation is always positive
and proportional to the gain error.
Notice that when the error is zero ($\|y(n)\| = \bar{e}$),
$\hat{g}(n+1) = \hat{g}(n)$

\subsection{Locking}
The {\tt agc} module permits the gain to be locked when, for example, the
header of a packet is received.
This is useful for effectively switching the AGC on and off during short,
burt-mode packet transmissions, particularly when the signal has a high-order
digital amplitude-modulation (e.g. 64-QAM) and the AGC could potentially
corrupt the data.
When the {\tt agc} object is locked, the internal gain control is not updated,
and the internal gain at the time of locking is applied directly to the output
signal.
%
Locking and unlocking is accomplished with the
{\tt agc\_crcf\_lock()} and
{\tt agc\_crcf\_unlock()} methods, respectively.

\subsection{Squelch}
The {\tt agc} module contains internal squelch control to allow the
controlling unit the ability to disable signal processing when the signal
level is too low.
In traditional radio design, the squelch circuit was used to suppress the
output of a receiver when the signal strength falls below a certain level,
primarily used to disable annoying static due to noise when no other operators
were transmitting.
Having said that, the squelch control in \liquid\ is actually somewhat of a
misnomer as it doesn't actually control the AGC, but rather just monitors the
dynamics of the signal level and returns its status to the controlling unit.
The squelch control follows six states
(enabled, rising edge trigger, signal high, falling edge trigger,
signal low, and timeout)
as depicted in
Figure~\ref{fig:module:agc:squelch} and
Table~\ref{tab:module:agc:squelch_codes}.
These states give the user flexibility in programming networks where packets
are transmitted in short bursts and the receiver needs to synchronize quickly.
The status of the squelch control is retrieved via the
{\tt agc\_crcf\_squelch\_get\_status()} method.

The typical control cycle for the AGC squelch is depicted in
Figure~\ref{fig:module:agc:squelch}.
Initially, squelch is enabled (code {\tt 0}) as the signal has been low for
quite some time.
When the beginning of a packet is received, the RSSI increases beyond the
squelch threshold (code {\tt 1}).
All subsequent samples above this threshold return a ``signal high'' status
(code {\tt 2}).
Once the signal level falls below the threshold, the squelch returns a
``falling edge trigger'' status (code {\tt 3}).
All subsequent samples below the threshold until timing out return a ``signal
low'' status (code {\tt 4}).
When the signal has been low for a sufficient period of time (defined by the
user), the squelch will return a ``timeout'' status (code {\tt 5}).
All subsequent samples below the threshold will return a ``squelch enabled''
status.

\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=16cm]{figures.pgf/agc_squelch}
\caption{{\tt agc\_crcf} squelch}
\label{fig:module:agc:squelch}
\end{figure}


% ------------ TABLE: AGC SQUELCH CODES ------------
\begin{table}[!ht]
\caption{{\tt agc} squelch codes}
\label{tab:module:agc:squelch_codes}
\centering
\begin{tabular*}{0.95\textwidth}{@{\extracolsep{\fill}}lll}

\hline\hline \\[-6pt]
{\bf code} & {\bf id} & {\bf description} \\[6pt]
\hline \\[-6pt]
{\tt 0} & {\tt LIQUID\_AGC\_SQUELCH\_ENABLED}    & squelch enabled \\
{\tt 1} & {\tt LIQUID\_AGC\_SQUELCH\_RISE}       & rising edge trigger \\
{\tt 2} & {\tt LIQUID\_AGC\_SQUELCH\_SIGNALHI}   & signal level high \\
{\tt 3} & {\tt LIQUID\_AGC\_SQUELCH\_FALL}       & falling edge trigger \\
{\tt 4} & {\tt LIQUID\_AGC\_SQUELCH\_SIGNALLO}   & signal level low, but no timeout \\
{\tt 5} & {\tt LIQUID\_AGC\_SQUELCH\_TIMEOUT}    & signal level low, timeout \\ \\[-6pt]

\hline\hline
\end{tabular*}
\end{table}%
% ------------------------


\subsubsection{methodology}
The reason for all six states (as opposed to just ``squelch on'' and ``squelch
off'') are to allow for the AGC to adjust to complex signal dynamics.
The default operation for the AGC is to {\it disable} the squelch.
For example if the AGC squelch control is in ``signal low'' mode
(state {\tt 4}) and the signal increases above the threshold before timeout,
the AGC will move back to the ``signal high'' mode (state {\tt 2}).
This is particularly useful for weak signals whose received signal strength is
hovering around the squelch threshold; it would be undesireable for the AGC to
enable the squelch in the middle of receiving a packet!

\subsubsection{auto-squelch}
The AGC module also allows for an auto-squelch mechanism which attempts to
track the signal threshold to the noise floor of the receiver.
This is accomplished by monitoring the signal level when squelch is enabled.
The auto-squelch mechanism has a 4dB headroom; if the signal level drops below
4dB beneath the squelch threshold, the threshold will be decremented.
This is useful for receiving weak signals slightly above the noise floor,
particularly when the exact noise floor is not known or varies slightly over
time.
Auto-squelch is enabled/disabled using the
{\tt agc\_crcf\_squelch\_enable\_auto()} and 
{\tt agc\_crcf\_squelch\_disable\_auto()} methods respectively.

\subsection{Usage}
Basic usage:
\input{listings/agc.example.c.tex}

