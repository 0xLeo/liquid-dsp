% 
% MODULE : filter
%
\section{filter}
\label{module:filter}
The filter module is at the core of \liquid's digital signal processing
functionality.
Filter design and implementation is a significant portion of radio
engineering, and consumes a considerable portion of the baseband receiver's
energy.
For linear digital modulation techniques (see section~\ref{module:modem}),
the matched filter is responsible for limiting the occupied bandwidth of the
transmitted signal while eliminating inter-symbol interference.

% autocorr
\subsection{{\tt autocorr} (auto-correlator)}
Implements an auto-correlator
% TODO check this equation
\[
    r_{xx}(n) = \sum_{k=0}^{N-1} {x(n-k)x^*(n-k-d)}
\]
where $N$ is the window length, and $d$ is the overlap delay.

% decim
\subsection{{\tt decim} (decimator)}
The {\tt decim} object family implements a basic interpolator with an integer
output-to-input resampling ratio.
It is essentially just a {\tt firfilt} object which operates on a block of
samples at a time.
An example of the decimator can be seen in figure~\ref{fig:module:filter:decim_crcf}.

%The same result can be accomplished with a {\tt firfilt} object...

\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_decim_crcf}
\caption{{\tt decim\_crcf} (decimator) demonstration, $D=4$}
\label{fig:module:filter:decim_crcf}
\end{figure}



% dds
\subsection{{\tt dds} (direct digital synthesizer)}

% firfilt
\subsection{{\tt firfilt} (finite impulse response filter)}
Finite impulse response (FIR) filter.
The output $y$ is the convolution of the input $x$ with the filter
coefficients (impulse response) $h$, viz
\[
    y(n) = \sum_{k=0}^{N-1}{ h(k) x(N-k-1) }
\]
where $\vec{h} = \{h_0,h_1,\ldots,h_{N-1}\}$ is the filter impulse response.

% firhilb
\subsection{{\tt firhilb} (finite impulse response Hilbert transform)}
The {\tt firhilb} object is a finite impulse response Hilbert transform which
converts between real and complex time series.
The interpolator takes a complex time series and produces real-valued samples
at twice the sample rate.
The decimator reverses the process by halving the sample rate of a real-valued
time series to a complex-valued one.

Typical trade-offs between filter length, side-lobe suppression, and
transition bandwidth apply.
The {\tt firhilb} object uses a half-band filter to implement the transform as
efficiently as possible.
While any filter length can be accepted, the {\tt firhilb} object internally
forces the length to be of the form $n=4m+1$.
A halfband filter of this length has $2m$ zeros and $2m+1$ non-zero
coefficients.
Of these non-zero coefficients, the center is exactly $1$ while the other $2m$
are even symmetric, and therefore only $m$ computations are needed...
[TODO: flesh out this section]

{\it See also:} {\tt resamp2} (section~\ref{module:filter:resamp2}),
FIR filter design (section~\ref{module:filter:firdes}).

\input{listings/firhilb.example.c.tex}

\begin{figure}
\centering
\subfigure[time] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_firhilb_decim_crcf_time}
}
\subfigure[PSD] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_firhilb_decim_crcf_freq}
}
\caption{{\tt firhilb\_crcf} (Hilbert transform) decimator demonstration. The
small signal at $f=0.13$ is due to aliasing as a result of imperfect image
rejection}
\label{fig:module:filter:firhilb_crcf}
\end{figure}

% firpfb
\subsection{{\tt firpfb} (finite impulse response polyphase filter bank)}

% interp
\subsection{{\tt interp} (interpolator)}
The {\tt interp} object implements a basic interpolator with an integer
output-to-input resampling ratio.

\input{listings/interp.example.c.tex}

\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_interp_crcf}
\caption{{\tt interp\_crcf} (interpolator) demonstration, $k=4$}
\label{fig:module:filter:interp_crcf}
\end{figure}


% qmfb
\subsection{{\tt qmfb} (quadrature mirror filter bank)}

% iirfilt
\subsection{{\tt iirfilt} (infinite impulse response filter)}
\label{module:filter:iirfilt}
The {\tt iirfilt\_crcf} object and family implement the infinite impulse
response (IIR) filters.
Also known as recursive filters, IIR filters allow a portion of the output to
be fed back into the input, thus creating an impulse response which is
non-zero for an infinite amount of time.
Formally, the output signal $y[n]$ may be written in terms of the input signal
$x[n]$ as
\[
    y[n] = \frac{1}{a_0} \left(
           \sum_{j=0}^{n_b-1}{ b_j x[n-j] } -
           \sum_{k=1}^{n_a-1}{ a_k y[n-k] }
           \right)
\]
where $\vec{b} = [b_0,b_1,\ldots,b_{n_b-1}]^T$ are the feed-forward parameters
and   $\vec{a} = [a_0,a_1,\ldots,a_{n_a-1}]^T$ are the feed-back parameters
of length $n_b$ and $n_a$, respectively.
The $z$-transform of the transfer function is therefore
\[
    H(z) = \frac{Y(z)}{X(z)}
         = \frac{\sum\limits_{j=0}^{n_b-1}{b_j z^{-j}}}
                {\sum\limits_{k=0}^{n_a-1}{a_k z^{-k}}}
         = \frac{ b_0 + b_1 z^{-1} + \cdots + b_{n_b-1} z^{n_b-1}}
                { a_0 + a_1 z^{-1} + \cdots + a_{n_a-1} z^{n_a-1}}
\]
Typically, $H(z)$ is normalized such that $a_0=1$.

For larger order filters (even as small as $n\approx 8$) the filter can become
unstable due to finite machine precision.
It is often therefore useful to express $H(z)$ in terms of second-order
sections.
For a filter of order $n$, these sections are denoted by the two
$(L+r)\times 3$ matrices $\vec{B}$ and $\vec{A}$
where $r=n \mod 2$ (0 for odd $n$, 1 for even $n$) and $L=(n-r)/2$.
\[
    H_d(z) = 
             \left[
                \frac{B_{r,0} + B_{r,1}z^{-1}}
                     {1       + A_{r,1}z^{-1}}
             \right]^r
             \prod_{k=1}^{L} {\left[
                \frac{B_{k,0} + B_{k,1}z^{-1} + B_{k,2}z^{-2}}
                     {1       + A_{k,1}z^{-1} + A_{k,2}z^{-2}}
             \right]}
\]
Notice that $H(z)$ is now a series of cascaded second-order IIR filters.
The `sos' form is practical when filters are designed from analog prototypes
where the poles and zeros are known.
\liquid\ implements second-order sections efficiently with the internal
{\tt iirfiltsos\_xxxt} object.
For a cascaded second-order section IIR filter, use
{\tt iirfilt\_xxxt\_create\_sos(B,A,n)}.

See also: {\tt iirdes} (IIR filter design).

\subsubsection{interface}
\label{module:filter:iirfilt:interface}
The interface to the {\tt iirfilt} object follows the convention of other
\liquid\ signal processing objects in that the ``{\tt xxxt}'' extension in
this section is only a placeholder for ``{\tt crcf}'' etc.

\begin{description}
\item[{\tt iirfilt\_xxxt\_create()}]
    creates a new {\tt iirfilt} object
\item[{\tt iirfilt\_xxxt\_create\_sos()}]
    creates a new {\tt iirfilt} object using second-order sections.
\item[{\tt iirfilt\_xxxt\_destroy()}]
    destroys an {\tt iirfilt} object, freeing all internally-allocated memory
    arrays and buffers.
\item[{\tt iirfilt\_xxxt\_print()}]
    prints the internals of an {\tt iirfilt} object.
\item[{\tt iirfilt\_xxxt\_clear()}]
    clears the filter's internal state.
\item[{\tt iirfilt\_xxxt\_execute()}]
    accepts one input sample and computes one output sample (i.e. executes one
    iteration of the filter).
\item[{\tt iirfilt\_xxxt\_get\_length()}]
    returns the order of the filter.
\end{description}

Listed below is a basic example of the interface.
For more detailed and extensive examples, refer to the {\tt examples/}
source directory.
\input{listings/iirfilt.example.c.tex}

\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_iirfilt_crcf_time}
\caption{{\tt iirfilt\_crcf} (infinite impulse response filter) demonstration}
\label{fig:module:filter:iirfilt_crcf}
\end{figure}


\subsection{{\tt iirdes} (infinite impulse response filter design)}
\label{module:filter:iirdes}
\liquid\ implements infinite impulse respone (IIR) filter design for the four
major classes of filters (Butterworth, Chebyshev, elliptic, and Bessel) by
first computing their analog low-pass prototypes, performing a bilinear
$z$-transform to convert to the digital domain, then transforming to the
appropriate band type (e.g. high pass) if necessary.
Externally, the user may abstract the entire process by using the {\tt iirdes}
method.

The internal IIR filter design process is described here:
\begin{enumerate}
\item Use {\tt butterf()}, {\tt cheby1f()}, {\tt cheby2f()}, {\tt ellipf()},
      {\tt besself()} to design a low-pass analog prototype in terms of
      complex zeros, poles, and gain.
      The {\tt azpkf} extension stands for ``analog zeros, poles, gain
      (floating-point).''

    \begin{description}
    \item[{\tt butter\_azpkf()}] Butterworth (maximally flat in the passband)
    \item[{\tt cheby1\_azpkf()}] Chebyshev Type-I (equiripple in the passband)
    \item[{\tt cheby2\_azpkf()}] Chebyshev Type-II (equiripple in the stopband)
    \item[{\tt ellip\_azpkf() }] elliptic filter (equiripple in the pass- and
        stopbands)
    \item[{\tt bessel\_azpkf()}] Bessel (maximally flat group delay)
    \end{description}

\item Compute frequency pre-warping factor, $m$, to set cutoff frequency (and
      center frequency if designing a band-pass or band-stop filter) using the
      {\tt iirdes\_freqprewarp()} method.

\item Convert the low-pass analog prototype to its digital equivalent (also in
      terms of zeros, poles, and gain) using the bilinear $z$-transform using
      the {\tt bilinear\_zpkf()} method.

\item Transform the low-pass digital prototype to high-pass, band-pass, or
      band-stop using the {\tt iirdes\_dzpk\_lp2bp()} method.
      For the band-pass and band-stop cases, the number of poles and zeros
      will need to be doubled.
    \begin{description}
    \item[LP] low-pass filter   : $s = m (1+z^{-1}) / (1-z^{-1})$
    \item[HP] high-pass filter  : $s = m (1-z^{-1}) / (1+z^{-1})$
    \item[BP] band-pass filter  : $s = m (1-c_0 z^{-1}+z^{-2}) / (1-z^{-2})$
    \item[BS] band-stop filter  : $s = m (1-z^{-2}) / (1-c_0 z^{-1}+z^{-2})$
    \end{description}

\item Transform the digital $z/p/k$ form of the filter to one of the two forms:
    \begin{itemize}
    \item[tf]  typical transfer function for digital iir filters of the form
        $B(z)/A(z)$, {\tt iirdes\_dzpk2tff()}
    \item[sos] second-order sections form : $\prod_k{ B_k(z)/A_k(z) }$, 
        {\tt iirdes\_dzpk2sosf()}.
        This is the preferred method.
    \end{itemize}

\item Create the filter object (e.g. iirfilt, iirqmfb) from the resulting
      structure using either {\tt iirfilt\_crcf\_create()} or
      {\tt iirfilt\_crcf\_create\_sosf()}

\end{enumerate}

%An extensive example is given in {\tt sandbox/iirdes\_example.c} while
%{\tt examples/iirdes\_example.c} gives the simplified interface.
A simplified example is given in {\tt examples/iirdes\_example.c}.

\subsubsection{{\tt iirdes} filter types}
\label{module:filter:iirdes:types}
There are currently five low-pass prototypes available for inifinite impulse
response filter design in \liquid,
\begin{description}
\item[{\tt LIQUID\_IIRDES\_BUTTER}]
    is a Butterworth filter.
    This is an all-pole analog design that has a maximally flat magnitude
    response in the passband.
    The analog prototype interface is {\tt butter\_azpkf()} which computes the
    roots $s_0,s_1,\ldots,s_{n-1}$ of the $n^{th}$-order Butterworth
    polynomial,
    \[
        s_k = \omega_c \exp\left\{
                    j \frac{\left(2k+n+1\right)\pi}{2n}
              \right\}
    \]
    for $k=0,1,\ldots,n-1$.
    Note that this results in a set of complex conjugate pairs such that
    $(-1)^n s_0 s_1 \cdots s_{n-1} = 1$.
    An example of a digital filter response can be found in
    figure~\ref{fig:module:filter:butter}
\item[{\tt LIQUID\_IIRDES\_CHEBY1}]
    is a Chebyshev Type-I filter.
    This design uses Chebyshev polynomials to create a filter with a sharper
    transition band than the Butterworth design by allowing ripples in the
    passband.
    The analog prototype interface is {\tt cheby1\_azpkf()}.
    An example of a digital filter response can be found in
    figure~\ref{fig:module:filter:cheby1}
\item[{\tt LIQUID\_IIRDES\_CHEBY2}]
    is a Chebyshev Type-II filter.
    This design is similar to that of Chebyshev Type-I, except that the
    Chebyshev polynomial is inverted.
    This inverts the magnitude response of the filter and exhibits an
    equiripple behavior in the stopband, rather than the passband.
    The analog prototype interface is {\tt cheby2\_azpkf()}.
    An example of a digital filter response can be found in
    figure~\ref{fig:module:filter:cheby2}
\item[{\tt LIQUID\_IIRDES\_ELLIP}]
    is an elliptic (Cauer) filter.
    This design allows ripples in both the passband and stopbands to create a
    filter with a very sharp transition band.
    The design process is somewhat more involved than the Butterworth and
    Chebyshev prototypes and requires solving the elliptic integral of
    different moduli.
    For a more detailed description we refer the interested reader to
    \cite{Orfanidis:2006}.
    The analog prototype interface is {\tt ellip\_azpkf()}.
    An example of a digital filter response can be found in
    figure~\ref{fig:module:filter:ellip}
\item[{\tt LIQUID\_IIRDES\_BESSEL}]
    is a Bessel filter.
    This is an all-pole analog design that has a maximally flat group delay
    response (maximally linear phase response).
    The solution to the design happens to be the roots to the Bessel
    polynomials of equal order.
    Computing the roots to the polynomial is, again, somewhat complex.
    For a more detailed description we refer the interested reader to
    \cite{Orchard:1965}.
    The analog prototype interface is {\tt bessel\_azpkf()}.
    An example of a digital filter response can be found in
    figure~\ref{fig:module:filter:bessel}
\end{description}

% 
% bilinear z-transform
%
\subsubsection{{\tt bilinear\_zpkf} (Bilinear $z$-transform)}
\label{module:filter:iirdes:bilinear}
The bilinear $z$-transform converts an analog prototype to its digital
counterpart.
Given a continuous time analog transfer function in zeros/poles/gain form
(``zpk''),
%\[
%    H(s) =  \frac{
%                r_0 + r_1 s + r_2 s^2 + \cdots + r_n s^n
%            }{
%                q_0 + q_1 s + q_2 s^2 + \cdots + q_m s^m
%            }
%\]
\[
    H_a(s) = k_a
            \frac{
                (s-z_{a0})(s-z_{a1})\cdots(s-z_{an-1})
            }{
                (s-p_{a0})(s-p_{a1})\cdots(s-p_{am-1})
            }
\]
the bilinear $z$-transform converts $H_a(s)$ into the discretized transfer
function $H_d(z)$ by mapping the $s$-plane onto the $z$-plane with the
approximation
\[
    s \approx \frac{2}{T}
              \frac{1-z^{-1}}{1 + z^{-1}}
\]
This maps $H_a(0) \rightarrow H_d(0)$ and
$H_a(\infty) \rightarrow H_d(\omega_s/2)$, however we are free to choose the
pre-warping factor which maps the cutoff frequency $\omega_c$.
\[
    s \rightarrow \omega_c
                  \cot\left(\frac{\pi \omega_c}{\omega_s}\right)
                  \frac{1-z^{-1}}{1+z^{-1}}
\]
Substituting this into $H_a(s)$ gives the discrete-time transfer function
\[
    H(z) = k_a \frac{
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-z_{a0}\right)
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-z_{a1}\right)
            \cdots
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-z_{an-1}\right)
           }{
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-p_{a0}\right)
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-p_{a1}\right)
            \cdots
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-p_{am-1}\right)
           }
\]
where $m=\omega_c \cot\left(\pi \omega_c / \omega_s\right)$ is the
frequency pre-warping factor, computed in \liquid\ via the method
{\tt iirdes\_freqprewarp()}.
Multiplying both the numerator an denominator by $(1+z^{-1})^{m-1}$...
...transforming the the analog zeros ($z_k$), poles ($p_k$), and gain ($k$) into
their digital equivalents. [reword]
...maps the analog zeros and poles $\{z_{ai},p_{ai}\}$
to digital $\{z_{i},p_{i}\}$...
\[
    H_d(s) = k_d
            \frac{
                (1-z_{0}z^{-1})(1-z_{1}z^{-1})\cdots(1-z_{n-1}z^{-1})
            }{
                (1-p_{0}z^{-1})(1-p_{1}z^{-1})\cdots(1-p_{n-1}z^{-1})
            }
\]
%
\liquid\ computes all of this with the {\tt bilinear\_zpk()} method.

% 
% filter transformations
%
\subsubsection{Filter transformations}
\label{module:filter:iirdes:transformations}
\begin{description}
\item[{\tt iirdes\_dzpk\_lp2hp()}]
    Converts a low-pass prototype to a high-pass prototype.
\item[{\tt iirdes\_dzpk\_lp2bp()}]
    Converts a low-pass prototype to a band-pass prototype.
\end{description}

...second-order sections form:
\[
    H_d(z) = H_0
             \left[
                G_0 \frac{1 + z^{-1}}
                         {1 - p_0 z^{-1}}
             \right]^r
             \prod_{k=1}^{L} {\left[
                G_i \frac{(1-z_iz^{-1})(1-z_i^*z^{-1})}
                         {(1-p_iz^{-1})(1-p_i^*z^{-1})}
             \right]}
\]
where $r=0$ when the filter order is odd, $r=1$ when the filter order is even,
and $L=(n-r)/2$.

% Butterworth IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 2mm 5mm 0mm 5mm, clip, width=0.55\textwidth]{figures.gen/filter_butter_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.37\textwidth]{figures.gen/filter_butter_zpk}
}
\caption{{\tt butterf} (Butterworth filter design)}
\label{fig:module:filter:butter}
\end{figure}

% Chebyshev type-I IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 2mm 5mm 0mm 5mm, clip, width=0.55\textwidth]{figures.gen/filter_cheby1_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.37\textwidth]{figures.gen/filter_cheby1_zpk}
}
\caption{{\tt cheby1f} (Chebyshev type-I filter design)}
\label{fig:module:filter:cheby1}
\end{figure}

% Chebyshev type-II IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 2mm 5mm 0mm 5mm, clip, width=0.55\textwidth]{figures.gen/filter_cheby2_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.37\textwidth]{figures.gen/filter_cheby2_zpk}
}
\caption{{\tt cheby2f} (Chebyshev type-II filter design)}
\label{fig:module:filter:cheby2}
\end{figure}

% Elliptic IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 2mm 5mm 0mm 5mm, clip, width=0.55\textwidth]{figures.gen/filter_ellip_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.37\textwidth]{figures.gen/filter_ellip_zpk}
}
\caption{{\tt ellipf} (Elliptic filter design)}
\label{fig:module:filter:ellip}
\end{figure}

% Bessel IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 2mm 5mm 0mm 5mm, clip, width=0.55\textwidth]{figures.gen/filter_bessel_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.37\textwidth]{figures.gen/filter_bessel_zpk}
}
\caption{{\tt besself} (Bessel filter design)}
\label{fig:module:filter:bessel}
\end{figure}


\subsection{{\tt resamp2} (halfband resampler)}
\label{module:filter:resamp2}
{\tt resamp2} is a half-band resampler used for efficient interpolation and
decimation.
The internal filter of the {\tt resamp2} object is a Kaiser-windowed $\sinc$
(see {\tt firdes\_kaiser\_window}, section~\ref{module:filter:firdes}) with
$f_c = 1/2$.
This makes the filter half-band, and puts the half-power (6 dB) cutoff point
$\omega_c$ at $\pi/2$ (one quarter of the sampling frequency).
In fact, any FIR filter design using a windowed $\sinc$ function with
periodicity $f_c=1/2$ will generate a Nyquist half-band filter (zero
inter-symbol interference).
This is because \cite[(4.6.3)]{Vaidyanathan:1993}
\[
    h(Mn) = 
        \begin{cases}
        c & n=0 \\
        0 & \text{otherwise}
        \end{cases}
\]
which holds for $h(n) = w(n) \sin(\pi n/M) / (\pi n)$ since
$\sin(\pi n/M) = 0$ for $n=$ any non-zero multiple of M.
Additionally, $M=2$ is the special case of half-band filters.
In particular half-band filtering is computationally efficient because half
the coefficients of the filter are zero, and the remaining half are symmetric
(so long as $w(n)$ is also symmetric).
In theory, this means that for a filter length of $4m+1$ taps, only $m$
computations are necessary \cite{harris:2004}.
The {\tt resamp2} object in \liquid\ uses a Kaser window for $w(n)$ for
several reasons, but in particular because it is nearly optimum, and it is
easy to trade side-lobe attenuation for transition bandwidth.

\subsection{{\tt resamp} (arbitrary resampler)}
For arbitrary (e.g. irrational) resampling ratios, the {\tt resamp} object is
the ideal solution.
It makes no restrictions on the output-to-input resampling ratio (e.g.
irrational values are fair game).
The arbitrary resampler uses a polyphase filter bank for interpolation between
available input sample points.

Because the number of outputs for each input is not fixed, the interface needs
some explaining.
Over time the true resampling ratio will equal the value specified, however
from one input to the next, the number of outputs will change.
For example, if the resampling rate is $2$, every input will produce exactly
two output samples.
However, if the resampling rate is $\sqrt{2} \approx 1.4142$, an input sample
will usually produce one output, but sometimes two.
In the limit (on {\it average}) however, the ratio of output samples to input
samples will be exactly $\sqrt{2}$.
The {\tt resamp} object handles this internally by storing the accumulated
sampling phase and produces an output for each overflow (i.e. values where the
accumulated phase is equal to or exceeds 1).

Below is a code example demonstrating the {\tt resamp} interface.
Notice that the {\tt resamp\_crcf\_execute()} method also returns the number
of samples written to the buffer.
This number will never exceed $\lceil r \rceil$.

\input{listings/resamp_crcf.example.c.tex}

Figure~\ref{fig:module:filter:resamp_crcf} gives a graphical depiction of the
arbitrary resampler, in both the time and frequency domains.
The time series has been aligned (shifted by the filter delay and scaled by
the resampling rate) to show equivalence.
Additionally, the signal's power spectrum has been scaled by $r$ to reflect
the change in sampling rate.
%Notice how the input and output spectra align, despite its

It is important to understand how filter design impacts the performance of the
resampler.
The {\tt resamp} object interpolates between available sample points to
minimize aliasing effects on the output signal.
This is apparent in the power spectral density plot in
figure~\ref{fig:module:filter:resamp_crcf} which shows very little aliasing on
the output signal.
Aliasing can be reduced by increasing the filter length at the cost of
additional computational complexity.
For synchronization of digital receivers, it is always good practice to
preceed the resampler with an anti-aliasing filter to remove out-of-band
interference.

See also: {\tt resamp2}, {\tt firpfb}, {\tt symsync},
{\tt examples/resamp\_crcf\_example.c}

\begin{figure}
\centering
\subfigure[time] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_resamp_crcf}
}
\subfigure[PSD] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_resamp_crcf_psd}
}
\caption{{\tt resamp\_crcf} (arbitrary resampler) demonstration,
$r=1/\sqrt{2}\approx0.7071$}
\label{fig:module:filter:resamp_crcf}
\end{figure}

\subsection{{\tt symsync} (symbol synchronizer)}
The {\tt symsync} object is a multi-rate symbol timing synchronizer useful for
locking a received digital signal to the receiver's clock.
It is effectively the same as the {\tt resamp} object, but includes an
internal control mechanism for tracking to timing phase and frequency offsets.
The filter structure is a polyphase representation of a Nyquist matched
filter.

\subsubsection{Theory}

\subsubsection{Loop Architecture}
Timing error:
\[
    e_\tau(nT_s) = \tanh\left( y(nT_s)\dot{y}(nT_s) \right)
\]
Filtered timing error:
\[
    \hat{e}_\tau(n) = \beta e_\tau(n) + \alpha \hat{e}_\tau(n-1)
\]
For a given bandwidth $b$, the loop filter coefficients are computed as
$\alpha = 1-b$ and $\beta = 0.22b$.
While certainly not optimized, it is important to understand the difficulty in
computing loop filter coefficients when a delay is introduced into the control
loop.
This delay is a by-product of the matched filter itself, in the sense that the
timing error estimate $e_\tau(n)$ is computed on $k m T_s$...

\subsection{{\tt firfarrow} (finite impulse response Farrow filter)}
\begin{description}
\item[{\tt firfarrow\_crcf\_create()}]
    creates a {\tt firfarrow} object.
\item[{\tt firfarrow\_crcf\_destroy()}]
    destroy object, freeing all internally-allocated memory.
\item[{\tt firfarrow\_crcf\_clear()}]
    clear filter internal memory buffer.
    This does not reset the delay.
\item[{\tt firfarrow\_crcf\_print()}]
    prints the filter's internal state to {\tt stdout}.
\item[{\tt firfarrow\_crcf\_push()}]
    push a single sample into the filter's internal buffer.
\item[{\tt firfarrow\_crcf\_set\_delay()}]
    set fractional delay of filter.
\item[{\tt firfarrow\_crcf\_execute()}]
    computes sample output.
\item[{\tt firfarrow\_crcf\_get\_length()}]
    returns length of the filter (number of taps)
\item[{\tt firfarrow\_crcf\_get\_coefficients()}]
    returns the internal filter coefficients.
\end{description}

\subsection{{\tt firdes} (finite impulse response filter design)}
\label{module:filter:firdes}

\subsubsection{Window prototype}
Basic idea: apply windowing function to truncated sinc

\begin{equation}
h(t) = w_n(t) \sinc(\Delta f t)
\end{equation}

where $w_n(t)$ is chosen from...

The Kaiser window is defined as...
\begin{equation}
\label{eqn:kaiser_window}
    w[n] = \frac{
        I_0\left(\pi\beta\sqrt{1-\left(\frac{n}{N/2}^2\right)}\right)
    }{
        I_0\left(\pi\beta\right)
    }
\end{equation}
where $I_\nu(z)$ is the modified Bessel function of the first kind of order
$\nu$.
\begin{equation}
\label{eqn:besseli_infinite_sum}
    I_\nu(z) = \sum_{k=0}^{\infty}{
        \frac{
            \left(\frac{1}{4}z^2\right)^k
        }{
            k!\Gamma(k+\nu+1)
        }
    }
\end{equation}
For more approximations to $I_0(z)$, see section~\ref{module:math} on the math
module.

The sum (\ref{eqn:besseli_infinite_sum}) converges quickly due to the
denominator increasing rapidly, thus only a few terms are necessary for
sufficient approximation.
An approximation for the value of $\beta$ to give a particular sidelobe level
for the window is given by {\tt kaiser\_beta\_slsl()}, and
the length of the filter can be approximated with
{\tt estimate\_req\_filter\_len()} (see section~\ref{module:filter:misc} for
more detail on these methods).

TODO : add discussion of interface for {\tt firdes\_kaiser\_window}.

\begin{figure}
\centering
\subfigure[time] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_kaiser_time}
}
\subfigure[PSD] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_kaiser_freq}
}
\caption{{\tt fir\_kaiser\_window()} demonstration, $f_c=0.15$,
$\Delta f=0.05$, $A_s=60$dB}
\label{fig:module:filter:firdes_kaiser}
\end{figure}


\subsubsection{{\tt rcos} (raised-cosine filter)}

\subsubsection{{\tt rrcos} (square-root raised-cosine filter)}
{\tt design\_rrc\_filter} calculates the coefficients for a square-root
raised-cosinee (RRC) finite impulse response (FIR) filter commonly used in
digital communications.
The input parameters are as follows
\begin{itemize}
    \item[$k$] : samples per symbol
    \item[$m$] : sample delay
    \item[$\beta$] : excess bandwidth (rolloff) factor
\end{itemize}
The function returns the filter coefficients in the buffer, $h$, which has been
allocated externally.  The length of the filter is always
\[
    h_{len} = 2 k m + 1
\]

The filter coefficients themselves are derived from the following equation
\[ 
    h\left[z\right] =
      4\beta \frac{ \cos\left[(1+\beta)\pi z\right] +
                    \sin\left[(1-\beta)\pi z\right] / (4\beta z) }
                  { \pi \sqrt{T}\left[ 1-16\beta^2z^2\right] }
\]
where $z=n/k-m$, and $T=1$ for most cases.
The function compensates for the two cases where $h[n]$ might be
undefined in the above equation, viz.
\[
    \mathop {\lim }\limits_{z \to 0 } h(z) = 1 - \beta + 4\beta/\pi
\]
and
\[
    \mathop {\lim }\limits_{z \to \pm \frac{1}{4\beta} } h(z) =
        \frac{\beta}{\sqrt{2}}
        \left[
            \left(1 + \frac{2}{\pi}\right)\sin\left(\frac{\pi}{4\beta}\right) +
            \left(1 - \frac{2}{\pi}\right)\cos\left(\frac{\pi}{4\beta}\right)
        \right]
\]


\subsubsection{{\tt firdespm}}
FIR filter desing using the Parks-McClellan algorithm.

% firdespm
\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_firdespm}
\caption{{\tt firdespm} multi-passband filter design demonstration}
\label{fig:module:filter:firdespm}
\end{figure}

\subsubsection{Miscellaneous functions}
\label{module:filter:misc}
Included in \liquid's 

\begin{description}
\item[{\tt estimate\_req\_filter\_len()}]
    returns an estimate of the required filter length, given a transition
    bandwidth $\Delta f$ and stopband attenuation $A_s$.
    The estimate uses Hermann's formula \cite{Herrmann:1973}
    \[
        N \approx \frac{
                D_{\infty}(\delta_1,\delta_2) - f(\delta_1,\delta_2)(\Delta f)^2
            }{
                \Delta f
            }
    \]
    where
    \[
        D_{\infty} (\delta_1,\delta_2) =
            \left[0.005309 t_1^2 + 0.07114 t_1 - 0.4761 \right] t_2
           -\left[0.00266  t_1^2 + 0.5941  t_1 + 0.4278 \right]
    \]
    and
    \[
        f(\delta_1,\delta_2) = 11.012 + 0.51244(t_1 - t_2)
    \]
    with $t_1 = \log_{10}\delta_1$ and $t_2 = \log_{10}\delta_2$.

\item[{\tt fir\_group\_delay()}]
    computes the group delay for a finite impulse-response filter.

\item[{\tt iir\_group\_delay()}]
    computes the group delay for an infinite impulse-response filter.

\item[{\tt iirdes\_isstable()}]
    checks the stability of an infinite impulse-response filter by computing
    the roots of the denominator (poles) and ensuring that they lie within the
    unit circle.

\item[{\tt kaiser\_beta\_slsl()}]
    returns an estimate of the Kaiser $\beta$ factor for a particular
    stop-band attenuation $A_s$.
    The estimate uses Kaiser's original formula \cite{Vaidyanathan:1993}, viz.
    \[
    \beta =
    \begin{cases}
        0.1102 (A_s - 8.7)      &   A_s > 50 \\
        0.5842 (A_s - 21)^{0.4} &   21 < A_s \le 50 \\
        0                       & \text{else}
    \end{cases}
    \]

\item[{\tt liquid\_filter\_autocorr()}]
    computes the auto-correlation of a filter at a specific lag.
\item[{\tt liquid\_filter\_isi()}]
    computes a filter's inter-symbol interference (both mean-squared error and
    maximum error).
    This is useful in comparing the performance of matched filter designs
    (e.g. root raised-cosine).

\end{description}

