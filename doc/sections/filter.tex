% 
% MODULE : filter
%
\section{filter}
\label{module:filter}

% autocorr
\subsection{{\tt autocorr} (auto-correlator)}
Implements an auto-correlator
% TODO check this equation
\[
    r_{xx}(n) = \sum_{k=0}^{N-1} {x(n-k)x^*(n-k-d)}
\]
where $N$ is the window length, and $d$ is the overlap delay.

% dds
\subsection{{\tt dds} (direct digital synthesizer)}

% firfilt
\subsection{{\tt firfilt} (finite impulse response filter)}
Finite impulse response filter.
The output $y$ is the convolution of the input $x$ with the filter
coefficients (impulse response) $h$, viz
\[
    y(n) = \sum_{k=0}^{N-1}{ h(k) x(N-k-1) }
\]
where $\vec{h} = \{h_0,h_1,\ldots,h_{N-1}\}$ is the filter impulse response.

% firhilb
\subsection{{\tt firhilb} (finite impulse response Hilbert transform)}
The {\tt firhilb} object is a finite impulse response Hilbert transform which
converts between real and complex time series.
The interpolator takes a complex time series and produces real-valued samples
at twice the sample rate.
The decimator reverses the process by halving the sample rate of a real-valued
time series to a complex-valued one.

Typical trade-offs between filter length, side-lobe suppression, and
transition bandwidth apply.
The {\tt firhilb} object uses a half-band filter to implement the transform as
efficiently as possible.
While any filter length can be accepted, the {\tt firhilb} object internally
forces the length to be of the form $n=4m+1$.
A halfband filter of this length has $2m$ zeros and $2m+1$ non-zero
coefficients.
Of these non-zero coefficients, the center is exactly $1$ while the other $2m$
are even symmetric, and therefore only $m$ computations are needed...
[TODO: flesh out this section]

{\it See also:} {\tt resamp2} (section~\ref{module:filter:resamp2}),
FIR filter design (section~\ref{module:filter:firdes}).

\input{listings/firhilb.example.c.tex}

\begin{figure}
\centering
\subfigure[time] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_firhilb_decim_crcf_time}
}
\subfigure[PSD] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_firhilb_decim_crcf_freq}
}
\caption{{\tt firhilb\_crcf} (Hilbert transform) decimator demonstration. The
small signal at $f=0.13$ is due to aliasing as a result of imperfect image
rejection}
\label{fig:module:filter:firhilb_crcf}
\end{figure}

% firpfb
\subsection{{\tt firpfb} (finite impulse response polyphase filter bank)}

% interp
\subsection{{\tt interp} (interpolator)}
The {\tt interp} object implements a basic interpolator with an integer
output-to-input resampling ratio.

\input{listings/interp.example.c.tex}

\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_interp_crcf}
\caption{{\tt interp\_crcf} (interpolator) demonstration, $k=4$}
\label{fig:module:filter:interp_crcf}
\end{figure}


% decim
\subsection{{\tt decim} (decimator)}
The {\tt decim} object implements a basic interpolator with an integer
input-to-output resampling ratio.

% qmfb
\subsection{{\tt qmfb} (quadrature mirror filter bank)}

% iirfilt
\subsection{{\tt iirfilt}}
Infinite impulse response filter.
\[
    y[n] = \frac{1}{a_0} \left(
           \sum_{j=0}^{n_b-1}{ b_j x[n-j] } -
           \sum_{k=1}^{n_a-1}{ a_k y[n-k] }
           \right)
\]
where $\vec{b} = [b_0,b_1,\ldots,b_{n_b-1}]^T$ are the feed-forward parameters
and   $\vec{a} = [a_0,a_1,\ldots,a_{n_a-1}]^T$ are the feed-back parameters
of length $n_b$ and $n_a$, respectively.
The $z$-transform of the transfer function is therefore
\[
    H(z) = \frac{Y(z)}{X(z)}
         = \frac{\sum\limits_{j=0}^{n_b-1}{b_j z^{-j}}}
                {\sum\limits_{k=0}^{n_a-1}{a_k z^{-k}}}
         = \frac{ b_0 + b_1 z^{-1} + \cdots + b_{n_b-1} z^{n_b-1}}
                { a_0 + a_1 z^{-1} + \cdots + a_{n_a-1} z^{n_a-1}}
\]
Typically, $H(z)$ is normalized such that $a_0=1$.

For larger order filters (even for $n\approx 8$) the filter can become
unstable due to finite machine precision.
It is often therefore useful to express $H(z)$ in terms of second-order
sections.
For a filter of order $n$, these sections are denoted by the two $L+r\times 3$
matrices $\vec{B}$ and $\vec{A}$
where $r=n \mod 2$ (0 for odd $n$, 1 for even $n$) and $L=(n-r)/2$.
\[
    H_d(z) = 
             \left[
                \frac{B_{r,0} + B_{r,1}z^{-1}}
                     {1       + A_{r,1}z^{-1}}
             \right]^r
             \prod_{k=1}^{L} {\left[
                \frac{B_{k,0} + B_{k,1}z^{-1} + B_{k,2}z^{-2}}
                     {1       + A_{k,1}z^{-1} + A_{k,2}z^{-2}}
             \right]}
\]
Notice that $H(z)$ is now a series of cascaded second-order IIR filters.
The `sos' form is practical when filters are designed from analog prototypes
where the poles and zeros are known.
\liquid\ implements second-order sections efficiently with the internal
{\tt iirfiltsos\_xxxt} object.
For a cascaded second-order section IIR filter, use
{\tt iirfilt\_xxxt\_create\_sos(B,A,n)}.

See also: {\tt iirdes} (IIR filter design).



\subsection{{\tt iirdes} (infinite impulse response filter design)}
Butterworth prototype:
\[
    H_a(s) = \frac{1}{B_n(s)}
           = \frac{
                (-1)^n s_0 s_1 \cdots s_{n-1}
            }{
                (s-s_0)(s-s_1) \cdots (s-s_{n-1})
            }
\]
where $B_n(s)$ is the $n^{th}$-order Butterworth polynomial with roots
$s_0,s_1,\ldots,s_{n-1}$.
\[
    s_k = \omega_c \exp\left\{
                j \frac{\left(2k+n+1\right)\pi}{2n}
          \right\}
\]
for $k=0,1,\ldots,n-1$.
Note that this results in a set of complex conjugate pairs... such that
$(-1)^n s_0 s_1 \cdots s_{n-1} = 1$.
Taking the bilinear $z$-transform
\[
    s \rightarrow \omega_c
                  \cot\left(\frac{\pi \omega_c}{\omega_s}\right)
                  \frac{1+z^{-1}}{1-z^{-1}}
\]
gives the discrete-time transfer function
\[
    H(z) = \frac{
            %(-1)^n s_0 s_1 \cdots s_{n-1}
            1
           }{
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-s_0\right)
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-s_1\right)
            \cdots
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-s_{n-1}\right)
           }
\]
Multiplying both the numerator an denominator by $(1+z^{-1})^{n-1}$...

\subsubsection{Bilinear $z$-transform}
Given a continuous time analog transfer function
\[
    H(s) =  \frac{
                r_0 + r_1 s + r_2 s^2 + \cdots + r_n s^n
            }{
                q_0 + q_1 s + q_2 s^2 + \cdots + q_m s^m
            }
\]
{\tt bilinear\_nd()} converts into discretized transfer function
\[
    H_d(z) = H_a(s)\Bigl.\Bigr|_{s = m\frac{1-z^{-1}}{1+z^{-1}}}
           =    \frac{
                    b_0 + b_1 z^{-1} + b_2 z^{-2} + \cdots + b_n z^{-n}
                }{
                    1   + a_1 z^{-1} + a_2 z^{-2} + \cdots + a_m z^{-m}
                }
\]
by expanding the polynomials in the numerator and denominator.
See {\tt poly\_binomial\_expand\_pm()} in the math section.

{\tt bilinear\_zpk()} converts from the analog zeros ($z_k$), poles ($p_k$),
gain ($k$) form
\[
    H_a(s) = k_a
            \frac{
                (s-z_{a0})(s-z_{a1})\cdots(s-z_{an-1})
            }{
                (s-p_{a0})(s-p_{a1})\cdots(s-p_{am-1})
            }
\]
...maps the analog zeros and poles $\{z_{ai},p_{ai}\}$
to digital $\{z_{i},p_{i}\}$...
\[
    H_d(s) = k_d
            \frac{
                (1-z_{0}z^{-1})(1-z_{1}z^{-1})\cdots(1-z_{n-1}z^{-1})
            }{
                (1-p_{0}z^{-1})(1-p_{1}z^{-1})\cdots(1-p_{n-1}z^{-1})
            }
\]
...second-order sections form:
\[
    H_d(z) = H_0
             \left[
                G_0 \frac{1 + z^{-1}}
                         {1 - p_0 z^{-1}}
             \right]^r
             \prod_{k=1}^{L} {\left[
                G_i \frac{(1-z_iz^{-1})(1-z_i^*z^{-1})}
                         {(1-p_iz^{-1})(1-p_i^*z^{-1})}
             \right]}
\]
where $r=0$ when the filter order is odd, $r=1$ when the filter order is even,
and $L=(n-r)/2$.

% Butterworth IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 2mm 5mm 0mm 5mm, clip, width=0.55\textwidth]{figures.gen/filter_butter_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.37\textwidth]{figures.gen/filter_butter_zpk}
}
\caption{{\tt butterf} (Butterworth filter design)}
\label{fig:module:filter:butter}
\end{figure}

% Chebyshev type-I IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 2mm 5mm 0mm 5mm, clip, width=0.55\textwidth]{figures.gen/filter_cheby1_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.37\textwidth]{figures.gen/filter_cheby1_zpk}
}
\caption{{\tt cheby1f} (Chebyshev type-I filter design)}
\label{fig:module:filter:cheby1}
\end{figure}

% Chebyshev type-II IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 2mm 5mm 0mm 5mm, clip, width=0.55\textwidth]{figures.gen/filter_cheby2_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.37\textwidth]{figures.gen/filter_cheby2_zpk}
}
\caption{{\tt cheby2f} (Chebyshev type-II filter design)}
\label{fig:module:filter:cheby2}
\end{figure}

% Elliptic IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 2mm 5mm 0mm 5mm, clip, width=0.55\textwidth]{figures.gen/filter_ellip_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.37\textwidth]{figures.gen/filter_ellip_zpk}
}
\caption{{\tt ellipf} (Elliptic filter design)}
\label{fig:module:filter:ellip}
\end{figure}

% Bessel IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 2mm 5mm 0mm 5mm, clip, width=0.55\textwidth]{figures.gen/filter_bessel_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.37\textwidth]{figures.gen/filter_bessel_zpk}
}
\caption{{\tt besself} (Bessel filter design)}
\label{fig:module:filter:bessel}
\end{figure}


\subsection{{\tt resamp2} (halfband resampler)}
\label{module:filter:resamp2}
{\tt resamp2} is a half-band resampler used for efficient interpolation and
decimation.
The internal filter of the {\tt resamp2} object is a Kaiser-windowed $\sinc$
(see {\tt firdes\_kaiser\_window}, section~\ref{module:filter:firdes}) with
$f_c = 1/2$.
This makes the filter half-band, and puts the half-power (6 dB) cutoff point
$\omega_c$ at $\pi/2$ (one quarter of the sampling frequency).
In fact, any FIR filter design using a windowed $\sinc$ function with
periodicity $f_c=1/2$ will generate a Nyquist half-band filter (zero
inter-symbol interference).
This is because \cite[(4.6.3)]{Vaidyanathan:1993}
\[
    h(Mn) = 
        \begin{cases}
        c & n=0 \\
        0 & \text{otherwise}
        \end{cases}
\]
which holds for $h(n) = w(n) \sin(\pi n/M) / (\pi n)$ since
$\sin(\pi n/M) = 0$ for $n=$ any non-zero multiple of M.
Additionally, $M=2$ is the special case of half-band filters.
In particular half-band filtering is computationally efficient because half
the coefficients of the filter are zero, and the remaining half are symmetric
(so long as $w(n)$ is also symmetric).
In theory, this means that for a filter length of $4m+1$ taps, only $m$
computations are necessary \cite{harris:2004}.
The {\tt resamp2} object in \liquid\ uses a Kaser window for $w(n)$ for
several reasons, but in particular because it is nearly optimum, and it is
easy to trade side-lobe attenuation for transition bandwidth.

\subsection{{\tt resamp} (arbitrary resampler)}
For arbitrary (e.g. irrational) resampling ratios, the {\tt resamp} object is
the ideal solution.
It makes no restrictions on the output-to-input resampling ratio (e.g.
irrational values are fair game).
The arbitrary resampler uses a polyphase filter bank for interpolation between
available input sample points.

Because the number of outputs for each input is not fixed, the interface needs
some explaining.
Over time the true resampling ratio will equal the value specified, however
from one input to the next, the number of outputs will change.
For example, if the resampling rate is $2$, every input will produce exactly
two output samples.
However, if the resampling rate is $\sqrt{2} \approx 1.4142$, an input sample
will usually produce one output, but sometimes two.
In the limit (on {\it average}) however, the ratio of output samples to input
samples will be exactly $\sqrt{2}$.
The {\tt resamp} object handles this internally by storing the accumulated
sampling phase and produces an output for each overflow (i.e. values where the
accumulated phase is equal to or exceeds 1).

Below is a code example demonstrating the {\tt resamp} interface.
Notice that the {\tt resamp\_crcf\_execute()} method also returns the number
of samples written to the buffer.
This number will never exceed $\lceil r \rceil$.

\input{listings/resamp_crcf.example.c.tex}

Figure~\ref{fig:module:filter:resamp_crcf} gives a graphical depiction of the
arbitrary resampler, in both the time and frequency domains.
The time series has been aligned (shifted by the filter delay and scaled by
the resampling rate) to show equivalence.
Additionally, the signal's power spectrum has been scaled by $r$ to reflect
the change in sampling rate.
%Notice how the input and output spectra align, despite its

It is important to understand how filter design impacts the performance of the
resampler.
The {\tt resamp} object interpolates between available sample points to
minimize aliasing effects on the output signal.
This is apparent in the power spectral density plot in
figure~\ref{fig:module:filter:resamp_crcf} which shows very little aliasing on
the output signal.
Aliasing can be reduced by increasing the filter length at the cost of
additional computational complexity.
For synchronization of digital receivers, it is always good practice to
preceed the resampler with an anti-aliasing filter to remove out-of-band
interference.

See also: {\tt resamp2}, {\tt firpfb}, {\tt symsync},
{\tt examples/resamp\_crcf\_example.c}

\begin{figure}
\centering
\subfigure[time] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_resamp_crcf}
}
\subfigure[PSD] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_resamp_crcf_psd}
}
\caption{{\tt resamp\_crcf} (arbitrary resampler) demonstration,
$r=1/\sqrt{2}\approx0.7071$}
\label{fig:module:filter:resamp_crcf}
\end{figure}

\subsection{{\tt symsync} (symbol synchronizer)}
The {\tt symsync} object is a multi-rate symbol timing synchronizer useful for
locking a received digital signal to the receiver's clock.
It is effectively the same as the {\tt resamp} object, but includes an
internal control mechanism for tracking to timing phase and frequency offsets.
The filter structure is a polyphase representation of a Nyquist matched
filter.

\subsubsection{Theory}

\subsubsection{Loop Architecture}
Timing error:
\[
    e_\tau(nT_s) = \tanh\left( y(nT_s)\dot{y}(nT_s) \right)
\]
Filtered timing error:
\[
    \hat{e}_\tau(n) = \beta e_\tau(n) + \alpha \hat{e}_\tau(n-1)
\]
For a given bandwidth $b$, the loop filter coefficients are computed as
$\alpha = 1-b$ and $\beta = 0.22b$.
While certainly not optimized, it is important to understand the difficulty in
computing loop filter coefficients when a delay is introduced into the control
loop.
This delay is a by-product of the matched filter itself, in the sense that the
timing error estimate $e_\tau(n)$ is computed on $k m T_s$...

\subsection{{\tt firfarrow} (finite impulse response Farrow filter)}

\subsection{{\tt firdes} (finite impulse response filter design)}
\label{module:filter:firdes}

\subsubsection{Window prototype}
Basic idea: apply windowing function to truncated sinc

\begin{equation}
h(t) = w_n(t) \sinc(\Delta f t)
\end{equation}

where $w_n(t)$ is chosen from...

The Kaiser window is defined as...
\begin{equation}
\label{eqn:kaiser_window}
    w[n] = \frac{
        I_0\left(\pi\beta\sqrt{1-\left(\frac{n}{N/2}^2\right)}\right)
    }{
        I_0\left(\pi\beta\right)
    }
\end{equation}
where $I_\nu(z)$ is the modified Bessel function of the first kind of order
$\nu$.
\begin{equation}
\label{eqn:besseli_infinite_sum}
    I_\nu(z) = \sum_{k=0}^{\infty}{
        \frac{
            \left(\frac{1}{4}z^2\right)^k
        }{
            k!\Gamma(k+\nu+1)
        }
    }
\end{equation}
For more approximations to $I_0(z)$, see section~\ref{module:math} on the math
module.

The sum (\ref{eqn:besseli_infinite_sum}) converges quickly due to the
denominator increasing rapidly, thus only a few terms are necessary for
sufficient approximation.
An approximation for the value of $\beta$ to give a particular sidelobe level
for the window is
\begin{equation}
    \beta =
    \begin{cases}
        0.1102 (A_s - 8.7)      &   A_s > 50 \\
        0.5842 (A_s - 21)^{0.4} &   21 < A_s \le 50 \\
        0                       & \text{else}
    \end{cases}
\end{equation}
where $A_s$ is the sidelobe suppression in decibels.
The length of the filter is approximated as
\[
    N = \frac{A_s}{11 \Delta f}
\]
where $\Delta f$ is the desired transition bandwidth of the filter.

TODO : add discussion of interface for {\tt firdes\_kaiser\_window}.

\begin{figure}
\centering
\subfigure[time] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_kaiser_time}
}
\subfigure[PSD] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_kaiser_freq}
}
\caption{{\tt fir\_kaiser\_window()} demonstration, $f_c=0.15$,
$\Delta f=0.05$, $A_s=60$dB}
\label{fig:module:filter:firdes_kaiser}
\end{figure}


\subsubsection{{\tt rcos} (raised-cosine filter)}

\subsubsection{{\tt rrcos} (square-root raised-cosine filter)}
{\tt design\_rrc\_filter} calculates the coefficients for a square-root
raised-cosinee (RRC) finite impulse response (FIR) filter commonly used in
digital communications.
The input parameters are as follows
\begin{itemize}
    \item[$k$] : samples per symbol
    \item[$m$] : sample delay
    \item[$\beta$] : excess bandwidth (rolloff) factor
\end{itemize}
The function returns the filter coefficients in the buffer, $h$, which has been
allocated externally.  The length of the filter is always
\[
    h_{len} = 2 k m + 1
\]

The filter coefficients themselves are derived from the following equation
\[ 
    h\left[z\right] =
      4\beta \frac{ \cos\left[(1+\beta)\pi z\right] +
                    \sin\left[(1-\beta)\pi z\right] / (4\beta z) }
                  { \pi \sqrt{T}\left[ 1-16\beta^2z^2\right] }
\]
where $z=n/k-m$, and $T=1$ for most cases.
The function compensates for the two cases where $h[n]$ might be
undefined in the above equation, viz.
\[
    \mathop {\lim }\limits_{z \to 0 } h(z) = 1 - \beta + 4\beta/\pi
\]
and
\[
    \mathop {\lim }\limits_{z \to \pm \frac{1}{4\beta} } h(z) =
        \frac{\beta}{\sqrt{2}}
        \left[
            \left(1 + \frac{2}{\pi}\right)\sin\left(\frac{\pi}{4\beta}\right) +
            \left(1 - \frac{2}{\pi}\right)\cos\left(\frac{\pi}{4\beta}\right)
        \right]
\]


\subsubsection{{\tt firdespm}}
FIR filter desing using the Parks-McClellan algorithm.

% firdespm
\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_firdespm}
\caption{{\tt firdespm} multi-passband filter design demonstration}
\label{fig:module:filter:firdespm}
\end{figure}


