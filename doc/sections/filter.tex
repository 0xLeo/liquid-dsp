% 
% MODULE : filter
%
\section{filter}
\label{module:filter}

% autocorr
\subsection{{\tt autocorr} (auto-correlator)}
Implements an auto-correlator
% TODO check this equation
\[
    r_{xx}(n) = \sum_{k=0}^{N-1} {x(n-k)x^*(n-k-d)}
\]
where $N$ is the window length, and $d$ is the overlap delay.

% dds
\subsection{{\tt dds} (direct digital synthesizer)}

% fir_filter
\subsection{{\tt fir\_filter} (finite impulse response filter)}
Finite impulse response filter.
The output $y$ is the convolution of the input $x$ with the filter
coefficients (impulse response) $h$, viz
\[
    y_n = \sum_{k=0}^{N-1}{ h_k x_{N-k-1} }
\]
where $\vec{h} = \{h_0,h_1,\ldots,h_{N-1}\}$ is the filter impulse response.

% firhilb
\subsection{{\tt firhilb} (finite impulse response Hilbert transform)}
The {\tt firhilb} object is a finite impulse response Hilbert transform which
converts between real and complex time series.
The interpolator takes a complex time series and produces real-valued samples
at twice the sample rate.
The decimator reverses the process by halving the sample rate of a real-valued
time series to a complex-valued one.

\input{listings/firhilb.example.c.tex}

% firpfb
\subsection{{\tt firpfb} (finite impulse response polyphase filter bank)}

% interp
\subsection{{\tt interp} (interpolator)}
The {\tt interp} object implements a basic interpolator with an integer
output-to-input resampling ratio.

% decim
\subsection{{\tt decim} (decimator)}
The {\tt decim} object implements a basic interpolator with an integer
input-to-output resampling ratio.

% qmfb
\subsection{{\tt qmfb} (quadrature mirror filter bank)}

% iir_filter
\subsection{{\tt iir\_filter}}
Infinite impulse response filter.
\[
    y_n = \sum_{k=0}^{N-1}{ b_k x_{N-k-1} } +
          \sum_{k=0}^{N-1}{ a_k y_{N-k-1} }
\]
where $\vec{b} = \{b_0,b_1,\ldots,b_{N-1}\}$ are the feed-forward parameters
and $\vec{a} = \{a_0,a_1,\ldots,a_{N-1}\}$ are the feed-back parameters.
\[
    H(z) = \frac{\sum_{k=0}^{N-1}{b_k z^{-k}}}
                {\sum_{k=0}^{N-1}{a_k z^{-k}}}
         = \frac{ b_0 + b_1 z^{-1} + \cdots + b_{N-1} z^{N-1}}
                { a_0 + a_1 z^{-1} + \cdots + a_{N-1} z^{N-1}}
\]
Typically, $H(z)$ is normalized such that $a_0=1$.

\subsection{{\tt resamp2} (halfband resampler)}
resamp2 is a halfband resampler used for efficient interpolation and
decimation

\subsection{{\tt resamp} (arbitrary resampler)}
For arbitrary (e.g. non-integer) resampling ratios, the {\tt resamp} object is
the ideal solution.
It makes no restrictions on the output-to-input resampling ratio (e.g.
irrational values are fair game).
The arbitrary resampler uses a polyphase filter bank for interpolation between
available input sample points.

See also: {\tt firpfb}, {\tt symsync}, {\tt symsync2}

\includegraphics[trim = 0mm 0mm 0mm 0mm, clip, height=12cm]{figures.gen/filter_resamp_crcf}

\subsection{{\tt symsync} (symbol synchronizer)}
The {\tt symsync} object is a multi-rate symbol timing synchronizer useful for
locking a received digital signal to the receiver's clock.
It is effectively the same as the {\tt resamp} object, but includes an
internal control mechanism for tracking to timing phase and frequency offsets.
The filter structure is a polyphase representation of a Nyquist matched
filter.

\subsubsection{Theory}

\subsubsection{Loop Architecture}
Timing error:
\[
    e_\tau(nT_s) = \tanh\left( y(nT_s)\dot{y}(nT_s) \right)
\]
Filtered timing error:
\[
    \hat{e}_\tau(n) = \beta e_\tau(n) + \alpha \hat{e}_\tau(n-1)
\]
For a given bandwidth $b$, the loop filter coefficients are computed as
$\alpha = 1-b$ and $\beta = 0.22b$.
While certainly not optimized, it is important to understand the difficulty in
computing loop filter coefficients when a delay is introduced into the control
loop.
This delay is a by-product of the matched filter itself, in the sense that the
timing error estimate $e_\tau(n)$ is computed on $k m T_s$...

\subsection{{\tt symsync2} (halfband symbol synchronizer)}

\subsection{{\tt firfarrow} (finite impulse response Farrow filter)}

\subsection{{\tt lf2} (second-order integrating loop filter)}

\subsection{{\tt rrcos}}
{\tt design\_rrc\_filter} calculates the coefficients for a square-root
raised-cosinee (RRC) finite impulse response (FIR) filter commonly used in
digital communications.
The input parameters are as follows
\begin{itemize}
    \item[$k$] : samples per symbol
    \item[$m$] : sample delay
    \item[$\beta$] : excess bandwidth (rolloff) factor
\end{itemize}
The function returns the filter coefficients in the buffer, $h$, which has been
allocated externally.  The length of the filter is always
\[
    h_{len} = 2 k m + 1
\]

The filter coefficients themselves are derived from the following equation
\[ 
    h\left[z\right] =
      4\beta \frac{ \cos\left[(1+\beta)\pi z\right] +
                    \sin\left[(1+\beta)\pi z\right] / (4\beta z) }
                  { \pi \sqrt{T}\left[ 1-16\beta^2z^2\right] }
\]
where $z=n/k-m$, and $T=1$ for most cases.
The function compensates for the two cases where $h[n]$ might be
undefined in the above equation, viz.
\[
    \mathop {\lim }\limits_{z \to 0 } h(z) =
      \frac{ 4\beta \left[ 1 + \frac{1-\beta\pi }{ 4\beta } \right] }
           { \pi\sqrt{T}\left( 1-16\beta^2 z^2 \right) }
\]
and
\[
    \mathop {\lim }\limits_{z \to \pm \frac{1}{4\beta} } h(z) =
        \frac{(1+\beta)}{2\pi}\sin\left[\frac{(1+\beta)\pi}{4\beta}\right]
      - \frac{(1-\beta)}{2}\cos\left[\frac{(1-\beta)\pi}{4\beta}\right]
      + \frac{2\beta}{\pi}\sin\left[\frac{(1-\beta)\pi}{4\beta}\right]
\]

\subsection{Windowed prototype}
\label{ch:filterdesign:window}

Basic idea: apply windowing function to truncated sinc

\begin{equation}
h(t) = w_n(t) \sinc(\Delta f t)
\end{equation}

where $w_n(t)$ is chosen from...

\subsection{Kaiser}
\label{ch:filterdesign:window:kaiser}
The Kaiser window is defined as...
\begin{equation}
\label{eqn:kaiser_window}
w[n] = \frac{I_0\left[\pi\beta\sqrt{1-\left(\frac{n}{N/2}^2\right)}\right]}{I_0\left(\pi\beta\right)}
\end{equation}
where $I_\nu(z)$ is the modified Bessel function of the first kind of order $\nu$.
\begin{equation}
\label{eqn:besseli_infinite_sum}
I_\nu(z) = \sum_{k=0}^{\infty}{\frac{\left(\frac{1}{4}z^2\right)^k}{k!\Gamma(k+\nu+1)}}
\end{equation}

The sum (\ref{eqn:besseli_infinite_sum}) converges quickly due to the
denominator increasing rapidly, thus only a few terms are necessary for
sufficient approximation.
An approximation for the value of $\beta$ to give a particular sidelobe level
for the window is
\begin{equation}
\hat{\beta}(\gamma) = \frac{\gamma + 21.45}{7.3}
\end{equation}
where $\gamma$ is the sidelobe suppression in decibels.
An approximation for the value of $\beta$ to give a particular transition
bandwidth for the window is
\begin{equation}
\hat{\beta}(\Delta f) = 10\Delta f \,\, (not\, accurate)
\end{equation}
where $0 < \Delta f < 0.5$ is the normalized transition bandwidth.


\includegraphics[trim = 0mm 0mm 0mm 0mm, clip, height=12cm]{figures.gen/filter_kaiser}
