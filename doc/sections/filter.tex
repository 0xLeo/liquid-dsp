% 
% MODULE : filter
%
\section{filter}
\label{module:filter}

% autocorr
\subsection{{\tt autocorr} (auto-correlator)}
Implements an auto-correlator
% TODO check this equation
\[
    r_{xx}(n) = \sum_{k=0}^{N-1} {x(n-k)x^*(n-k-d)}
\]
where $N$ is the window length, and $d$ is the overlap delay.

% dds
\subsection{{\tt dds} (direct digital synthesizer)}

% fir_filter
\subsection{{\tt fir\_filter} (finite impulse response filter)}
Finite impulse response filter.
The output $y$ is the convolution of the input $x$ with the filter
coefficients (impulse response) $h$, viz
\[
    y_n = \sum_{k=0}^{N-1}{ h_k x_{N-k-1} }
\]
where $\vec{h} = \{h_0,h_1,\ldots,h_{N-1}\}$ is the filter impulse response.

% firhilb
\subsection{{\tt firhilb} (finite impulse response Hilbert transform)}
The {\tt firhilb} object is a finite impulse response Hilbert transform which
converts between real and complex time series.
The interpolator takes a complex time series and produces real-valued samples
at twice the sample rate.
The decimator reverses the process by halving the sample rate of a real-valued
time series to a complex-valued one.

\input{listings/firhilb.example.c.tex}

% firpfb
\subsection{{\tt firpfb} (finite impulse response polyphase filter bank)}

% interp
\subsection{{\tt interp} (interpolator)}
The {\tt interp} object implements a basic interpolator with an integer
output-to-input resampling ratio.

\input{listings/interp.example.c.tex}

\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_interp_crcf}
\caption{{\tt interp\_crcf} (interpolator) demonstration, $k=4$}
\label{fig:module:filter:interp_crcf}
\end{figure}


% decim
\subsection{{\tt decim} (decimator)}
The {\tt decim} object implements a basic interpolator with an integer
input-to-output resampling ratio.

% qmfb
\subsection{{\tt qmfb} (quadrature mirror filter bank)}

% iir_filter
\subsection{{\tt iir\_filter}}
Infinite impulse response filter.
\[
    y[n] = \frac{1}{a_0} \left(
           \sum_{j=0}^{n_b-1}{ b_j x[n-j] } -
           \sum_{k=1}^{n_a-1}{ a_k y[n-k] }
           \right)
\]
where $\vec{b} = [b_0,b_1,\ldots,b_{n_b-1}]^T$ are the feed-forward parameters
and   $\vec{a} = [a_0,a_1,\ldots,a_{n_a-1}]^T$ are the feed-back parameters
of length $n_b$ and $n_a$, respectively.
The $z$-transform of the transfer function is therefore
\[
    H(z) = \frac{Y(z)}{X(z)}
         = \frac{\sum\limits_{j=0}^{n_b-1}{b_j z^{-j}}}
                {\sum\limits_{k=0}^{n_a-1}{a_k z^{-k}}}
         = \frac{ b_0 + b_1 z^{-1} + \cdots + b_{n_b-1} z^{n_b-1}}
                { a_0 + a_1 z^{-1} + \cdots + a_{n_a-1} z^{n_a-1}}
\]
Typically, $H(z)$ is normalized such that $a_0=1$.

See also: {\tt iirdes} (IIR filter design).

\subsection{{\tt iirdes} (IIR filter design)}
Butterworth prototype:
\[
    H_a(s) = \frac{1}{B_n(s)}
           = \frac{
                (-1)^n s_0 s_1 \cdots s_{n-1}
            }{
                (s-s_0)(s-s_1) \cdots (s-s_{n-1})
            }
\]
where $B_n(s)$ is the $n^{th}$-order Butterworth polynomial with roots
$s_0,s_1,\ldots,s_{n-1}$.
\[
    s_k = \omega_c \exp\left\{
                j \frac{\left(2k+n+1\right)\pi}{2n}
          \right\}
\]
for $k=0,1,\ldots,n-1$.
Note that this results in a set of complex conjugate pairs... such that
$(-1)^n s_0 s_1 \cdots s_{n-1} = 1$.
Taking the bilinear $z$-transform
\[
    s \rightarrow \omega_c
                  \cot\left(\frac{\pi \omega_c}{\omega_s}\right)
                  \frac{1+z^{-1}}{1-z^{-1}}
\]
gives the discrete-time transfer function
\[
    H(z) = \frac{
            %(-1)^n s_0 s_1 \cdots s_{n-1}
            1
           }{
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-s_0\right)
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-s_1\right)
            \cdots
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-s_{n-1}\right)
           }
\]
Multiplying both the numerator an denominator by $(1+z^{-1})^{n-1}$...

\subsubsection{Bilinear $z$-transform}
Given a continuous time analog transfer function
\[
    H(s) =  \frac{
                r_0 + r_1 s + r_2 s^2 + \cdots + r_n s^n
            }{
                q_0 + q_1 s + q_2 s^2 + \cdots + q_m s^m
            }
\]
{\tt bilinear\_nd()} converts into discretized transfer function
\[
    H_d(z) = H_a(s)\Bigl.\Bigr|_{s = m\frac{1-z^{-1}}{1+z^{-1}}}
           =    \frac{
                    b_0 + b_1 z^{-1} + b_2 z^{-2} + \cdots + b_n z^{-n}
                }{
                    1   + a_1 z^{-1} + a_2 z^{-2} + \cdots + a_m z^{-m}
                }
\]
by expanding the polynomials in the numerator and denominator.
See {\tt poly\_binomial\_expand\_pm()} in the math section.

{\tt bilinear\_zpk()} converts from the analog zeros ($z_k$), poles ($p_k$),
gain ($k$) form
\[
    H_a(s) = k_a
            \frac{
                (s-z_{a0})(s-z_{a1})\cdots(s-z_{an-1})
            }{
                (s-p_{a0})(s-p_{a1})\cdots(s-p_{am-1})
            }
\]
...maps the analog zeros and poles $\{z_{ai},p_{ai}\}$
to digital $\{z_{i},p_{i}\}$...
\[
    H_d(s) = k_d
            \frac{
                (1-z_{0}z^{-1})(1-z_{1}z^{-1})\cdots(1-z_{n-1}z^{-1})
            }{
                (1-p_{0}z^{-1})(1-p_{1}z^{-1})\cdots(1-p_{n-1}z^{-1})
            }
\]
...second-order sections form:
\[
    H_d(s) = H_0
             \left[
                G_0 \frac{1 + z^{-1}}
                         {1 - p_0 z^{-1}}
             \right]^r
             \prod_{k=1}^{L} {\left[
                G_i \frac{(1-z_iz^{-1})(1-z_i^*z^{-1})}
                         {(1-p_iz^{-1})(1-p_i^*z^{-1})}
             \right]}
\]
where $r=0$ when the filter order is odd, $r=1$ when the filter order is even,
and $L=(n-r)/2$.

% Butterworth IIR filter design
\begin{figure}
\centering
\includegraphics[trim = 0mm 0mm 0mm 0mm, clip,width=13cm]{figures.gen/filter_butter}
\caption{{\tt butterf} (Butterworth filter design)}
\label{fig:module:filter:butter}
\end{figure}

% Chebyshev type-I IIR filter design
\begin{figure}
\centering
\includegraphics[trim = 0mm 0mm 0mm 0mm, clip,width=13cm]{figures.gen/filter_cheby1}
\caption{{\tt cheby1f} (Chebyshev type-I filter design)}
\label{fig:module:filter:cheby1}
\end{figure}

% Chebyshev type-II IIR filter design
\begin{figure}
\centering
\includegraphics[trim = 0mm 0mm 0mm 0mm, clip,width=13cm]{figures.gen/filter_cheby2}
\caption{{\tt cheby2f} (Chebyshev type-II filter design)}
\label{fig:module:filter:cheby2}
\end{figure}

% Elliptic IIR filter design
\begin{figure}
\centering
\includegraphics[trim = 0mm 0mm 0mm 0mm, clip,width=13cm]{figures.gen/filter_ellip}
\caption{{\tt ellipf} (Elliptic filter design)}
\label{fig:module:filter:ellip}
\end{figure}

% Bessel IIR filter design
\begin{figure}
\centering
\includegraphics[trim = 0mm 0mm 0mm 0mm, clip,width=13cm]{figures.gen/filter_bessel}
\caption{{\tt besself} (Bessel filter design)}
\label{fig:module:filter:bessel}
\end{figure}


\subsection{{\tt resamp2} (halfband resampler)}
resamp2 is a halfband resampler used for efficient interpolation and
decimation

\subsection{{\tt resamp} (arbitrary resampler)}
For arbitrary (e.g. non-integer) resampling ratios, the {\tt resamp} object is
the ideal solution.
It makes no restrictions on the output-to-input resampling ratio (e.g.
irrational values are fair game).
The arbitrary resampler uses a polyphase filter bank for interpolation between
available input sample points.

See also: {\tt firpfb}, {\tt symsync}, {\tt symsync2}

\begin{figure}
\centering
\subfigure[time] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_resamp_crcf}
}
\subfigure[PSD] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_resamp_crcf_psd}
}
\caption{{\tt resamp\_crcf} (arbitrary resampler) demonstration, $r=0.9$}
\label{fig:module:filter:resamp_crcf}
\end{figure}

\subsection{{\tt symsync} (symbol synchronizer)}
The {\tt symsync} object is a multi-rate symbol timing synchronizer useful for
locking a received digital signal to the receiver's clock.
It is effectively the same as the {\tt resamp} object, but includes an
internal control mechanism for tracking to timing phase and frequency offsets.
The filter structure is a polyphase representation of a Nyquist matched
filter.

\subsubsection{Theory}

\subsubsection{Loop Architecture}
Timing error:
\[
    e_\tau(nT_s) = \tanh\left( y(nT_s)\dot{y}(nT_s) \right)
\]
Filtered timing error:
\[
    \hat{e}_\tau(n) = \beta e_\tau(n) + \alpha \hat{e}_\tau(n-1)
\]
For a given bandwidth $b$, the loop filter coefficients are computed as
$\alpha = 1-b$ and $\beta = 0.22b$.
While certainly not optimized, it is important to understand the difficulty in
computing loop filter coefficients when a delay is introduced into the control
loop.
This delay is a by-product of the matched filter itself, in the sense that the
timing error estimate $e_\tau(n)$ is computed on $k m T_s$...

\subsection{{\tt symsync2} (halfband symbol synchronizer)}

\subsection{{\tt firfarrow} (finite impulse response Farrow filter)}

\subsection{{\tt lf2} (second-order integrating loop filter)}

\subsection{{\tt rrcos}}
{\tt design\_rrc\_filter} calculates the coefficients for a square-root
raised-cosinee (RRC) finite impulse response (FIR) filter commonly used in
digital communications.
The input parameters are as follows
\begin{itemize}
    \item[$k$] : samples per symbol
    \item[$m$] : sample delay
    \item[$\beta$] : excess bandwidth (rolloff) factor
\end{itemize}
The function returns the filter coefficients in the buffer, $h$, which has been
allocated externally.  The length of the filter is always
\[
    h_{len} = 2 k m + 1
\]

The filter coefficients themselves are derived from the following equation
\[ 
    h\left[z\right] =
      4\beta \frac{ \cos\left[(1+\beta)\pi z\right] +
                    \sin\left[(1+\beta)\pi z\right] / (4\beta z) }
                  { \pi \sqrt{T}\left[ 1-16\beta^2z^2\right] }
\]
where $z=n/k-m$, and $T=1$ for most cases.
The function compensates for the two cases where $h[n]$ might be
undefined in the above equation, viz.
\[
    \mathop {\lim }\limits_{z \to 0 } h(z) =
      \frac{ 4\beta \left[ 1 + \frac{1-\beta\pi }{ 4\beta } \right] }
           { \pi\sqrt{T}\left( 1-16\beta^2 z^2 \right) }
\]
and
\[
    \mathop {\lim }\limits_{z \to \pm \frac{1}{4\beta} } h(z) =
        \frac{(1+\beta)}{2\pi}\sin\left[\frac{(1+\beta)\pi}{4\beta}\right]
      - \frac{(1-\beta)}{2}\cos\left[\frac{(1-\beta)\pi}{4\beta}\right]
      + \frac{2\beta}{\pi}\sin\left[\frac{(1-\beta)\pi}{4\beta}\right]
\]

\subsection{Windowed prototype}
\label{ch:filterdesign:window}

Basic idea: apply windowing function to truncated sinc

\begin{equation}
h(t) = w_n(t) \sinc(\Delta f t)
\end{equation}

where $w_n(t)$ is chosen from...

\subsection{Kaiser}
\label{ch:filterdesign:window:kaiser}
The Kaiser window is defined as...
\begin{equation}
\label{eqn:kaiser_window}
w[n] = \frac{I_0\left[\pi\beta\sqrt{1-\left(\frac{n}{N/2}^2\right)}\right]}{I_0\left(\pi\beta\right)}
\end{equation}
where $I_\nu(z)$ is the modified Bessel function of the first kind of order $\nu$.
\begin{equation}
\label{eqn:besseli_infinite_sum}
I_\nu(z) = \sum_{k=0}^{\infty}{\frac{\left(\frac{1}{4}z^2\right)^k}{k!\Gamma(k+\nu+1)}}
\end{equation}
For more approximations to $I_0(z)$, see the math section.

The sum (\ref{eqn:besseli_infinite_sum}) converges quickly due to the
denominator increasing rapidly, thus only a few terms are necessary for
sufficient approximation.
An approximation for the value of $\beta$ to give a particular sidelobe level
for the window is
\begin{equation}
\hat{\beta}(\gamma) = \frac{\gamma + 21.45}{7.3}
\end{equation}
where $\gamma$ is the sidelobe suppression in decibels.
An approximation for the value of $\beta$ to give a particular transition
bandwidth for the window is
\begin{equation}
\hat{\beta}(\Delta f) = 10\Delta f \,\, (not\, accurate)
\end{equation}
where $0 < \Delta f < 0.5$ is the normalized transition bandwidth.


\includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_kaiser}


