% 
% MODULE : fec (forward error correction)
%

\newpage
\section{fec (forward error correction)}
\label{module:fec}
%(basic), checksum, crc, Hamming block codes...
The fec module implements a set of forward error-correction codes for
ensuring and validating data integrity through a noisy channel.
Redundant ``parity'' bits are added to a data sequence to help correct
errors introduced by the channel.
The number of correctable errors depends on the number of parity bits of the
coding scheme, which in turn affects its rate (efficiency).
The {\tt fec} object realizes forward error-correction capabilities in
\liquid\ while the methods {\tt checksum()} and {\tt crc32()} strictly
implement error detection.
Certain FEC schemes are only available to \liquid\ by installing the external
{\tt libfec} library \cite{libfec:web}, available as a free download.
A few low-rate (and fairly low efficiency) codes are availble internally.

%The {\tt packetizer} object (Section~\ref{module:framing:packetizer})
%relies on the {\tt fec} objects and {\tt crc32} functions.

\subsection{Cyclic Redundancy Check (Error Detection)}
\label{module:fec:crc}

A cyclic redundancy check (CRC) is, in essence, a strong algebraic error
detection code that computes a key on a block of data using base-2
polynomials.
While it is a strong error-detection method, a CRC is not an error-correction
code.
Here is a simple example:
%
\input{listings/crc.example.c.tex}
%
Also available for error detection in \liquid\ is a checkssum.
A checksum is a simple way to validate data received through un-reliable means
(e.g. a noisy channel).
A checksum is, in essence, a weak error detection code that simply counts the
number of ones in a block of data (modulo 256).
The limitation, however, is that multiple bit errors might result in a false
positive validation of the corrupted data.
The checksum is not a strong an error detection scheme as the cyclic
redundany check.
%
Table~\ref{tab:crc:codecs} lists the available codecs and gives a brief
description for each.
%
% ------------ TABLE: CRC CODING SCHEMES ------------
\begin{table*}
\caption{Error-detection codecs available in \liquid}
\label{tab:crc:codecs}
\centering
{\small
\begin{tabular*}{0.75\textwidth}{l@{\extracolsep{\fill}}ll}
\toprule
{\it scheme} &
{\it size (bits)} &
{\it description}\\\otoprule
%
{\tt CRC\_UNKNOWN}      & -     & unknown/unsupported scheme\\
{\tt CRC\_NONE}         & 0     & no error-detection\\
{\tt CRC\_CHECKSUM}     & 8     & basic checksum\\
{\tt CRC\_8}            & 8     &  8-bit CRC, poly={\tt 0x07}\\
{\tt CRC\_16}           & 16    & 16-bit CRC, poly={\tt 0x8005}\\
{\tt CRC\_24}           & 24    & 24-bit CRC, poly={\tt 0x5D6DCB}\\
{\tt CRC\_32}           & 32    & 32-bit CRC, poly={\tt 0x04C11DB7}\\\bottomrule

\end{tabular*}
}
\end{table*}%
% ------------------------
%
For a detailed example program, see {\tt examples/crc\_example.c} in the
main \liquid\ directory.


\subsection{{\tt h74}, {\tt h84}, {\tt h128} (Hamming codes)}
\label{module:fec:hamming}
Hamming codes are a specific type of block
code which use parity bits capable of correcting one bit error in the block.
With the addition of an extra parity bit, they are able to detect up to two
errors, but are still only able to correct one.
\liquid\ implements the Hamming(7,4), Hamming(8,4), and Hamming(12,8)
codes.
The Hamming(8,4) can detect one additional error over the Hamming(7,4)
code;
however at the time of writing this document the number of detected
errors is not passed to the user so the Hamming(8,4) code is effectively
the same as Hamming(7,4) but with a lower rate.
%
Additionally, \liquid\ implements the Hamming(12,8) code which accepts an
8-bit symbol and adds four parity bits, extending it to a 12-bit symbol.
This yields a theoretical rate of $2/3$, and actually has a performance very
similar to that of the Hamming(7,4) code, even with a higher rate.

\subsection{{\tt rep3}, {\tt rep5} (simple repeat codes)}
\label{module:fec:rep}
The {\tt rep3} code is a simple repeat code which simply repeats the message
twice (transmits it three times).
The decoder takes a majority vote of the bits received by applying a simple
series bit masks.
If the original bit is represented as $s$, then the transmitted bits are
$s s s$.
Let the received bit sequence be $r_0 r_1 r_2$.
The estimated transmitted bit is {\tt 0} if the sum of the received bits is
less than 2, and {\tt 1} otherwise.
This is equivalent to
\[
    \hat{s} =   (r_0 \land r_1) + 
                (r_0 \land r_2) + 
                (r_1 \land r_2) 
\]
where $+$ represents logical {\it or} and $\land$ represents
logical {\it and}.
An error is detected if
\[
    \hat{e} =   (r_0 \oplus r_1) + 
                (r_0 \oplus r_2) + 
                (r_1 \oplus r_2) 
\]
where $\oplus$ represents logical {\it exclusive or}.
In this fashion it is easy to decode several bytes of data at a time because
machine architectures have low-level bit-wise manipulation instructions which
can compute logical {\it exclusive or} and {\it or} very quickly.
This is precisely how \liquid\ decodes {\tt rep3} data, only in this case,
$s$, $r_0$, $r_1$, and $r_2$ represent a bytes of data rather than bits.

The {\tt rep5} code operates similarly, except that it transmits five copies
of the original data sequence, rather than just three.
The decoder takes the five received bits $r_0,\ldots,r_4$ and adds (modulo
2) the logical {\it and} of every combination of three bits, viz
\[
    \hat{s} = \sum_{i\ne j \ne k} {(r_i \land r_j \land r_k)}
\]
This roughly doubles the number of clock cycles to decode over {\tt rep3}.

It is well-known that repeat codes do not have strong error-correction
capabilities for their rate, are are located far from the Shannon capacity
bound \cite{Proakis:2001}.
They are exceptionally weak relative to convolutional Viterbi and Reed-Solomon
codes.
However, their simplicity in implementation and low computational complexity
gains them a place in digital communications, particularly in software radios
where spectral efficiency goals might be secondary to processing contraints.

\subsection{{\tt libfec} (convolutional and  Reed-Solomon codes)}
\label{module:fec:libfecv}
\liquid\ takes advantage of convolutional and Reed-Solomon codes defined in
{\tt libfec} \cite{libfec:web}.
These codes have much stronger error-correction capabilities than {\tt rep3},
{\tt rep5}, {\tt h74}, {\tt h84}, and {\tt h128}
but are also much more computationally intensive to the host processor.
\liquid\ uses the rate $1/2 (K=7)$, $1/2 (K=9)$, $1/3 (K=9)$, and
$r1/6 (K=15)$ codes defined in {\tt libfec}, but extends the two half-rate
codes to punctured codes.
These punctured codes (also known as ``perforated'' codes) are not as strong
and cannot correct as many errors, but are more efficient and use less
overhead than their half-rate counterparts.
%
The 8-bit Reed-Solomon code is a (255,223) block code, also defined in
{\tt libfec}.
Nominally, the scheme accepts 223 bytes (8-bit symbols) and adds 32 parity
symbols to form a 255-symbol encoded block.
%
{\tt libfec} is an external library that \liquid\ will leverage if
installed, but will still compile otherwise
(see Section~\ref{section:installation:building} for details).

\subsection{Interface}
\label{module:fec:interface}
In designing the {\tt fec} interface, we have tried to keep simplicity and
reconfigurability in mind.
The various forward error-correction schemes accept bits or symbols
formatted in different lengths and have vastly different interfaces.
This potentially makes switching from one scheme to another difficult as one
needs to restructure the data accordingly.
\liquid\ takes care of all this formatting under the hood; regardless of the
scheme used, the {\tt fec} object accepts a block of uncoded data bytes and
encodes them into an output block of coded data bytes.

%The goal is to allow flexibility in the allocation ...
%TODO finish interface description

\begin{description}
\item[{\tt fec\_create(scheme,*opts)}]
    creates a {\tt fec} object of a specific scheme
    (see Table~\ref{tab:fec:codecs} for available codecs).
    Notice that the length of the input message does not need to be
    specified until {\tt encode()} or {\tt decode()} is invoked.
    The second argument is intended for future development and should be
    ignored by passing the {\tt NULL} pointer
    (see example below).
\item[{\tt fec\_recreate(q,scheme,opts)}]
    recreates an existing {\tt fec} object with a different scheme.
\item[{\tt fec\_destroy(q)}]
    destroys a {\tt fec} object, freeing all internally-allocated memory
    arrays.
\item[{\tt fec\_encode(q,n,*msg\_dec,*msg\_enc)}]
    runs the error-correction encoder scheme on an $n$-byte input data
    array {\tt msg\_dec}, storing the result in the output array
    {\tt msg\_enc}.
    To obtain the length of the output array necessary, use the
    {\tt fec\_get\_enc\_msg\_length()} method.
\item[{\tt fec\_decode(q,n,*msg\_enc,*msg\_dec)}]
    runs the error-correction decoder on an input array
    {\tt msg\_enc} of $k$ encoded bytes.
    The resulting best-effort decoded message is written to the $n$-byte
    output array {\tt msg\_dec}, allocated by the user.
    Notice that like the {\tt fec\_encode()} method, the input length
    $n$ refers to the {\em decoded} message length.
    Depending upon the error-correction capabilities of the scheme, the
    resulting data might have been corrupted,
    and therefore it is recommended to use either a checksum or a
    cyclic redundancy check (section~\ref{module:fec:crc})
    to validate data integrity.
\item[{\tt fec\_get\_enc\_msg\_length(scheme,n)}]
    returns the length $k$ of the encoded message in bytes
    for an uncoded input of $n$ bytes using the specified encoding
    scheme.
    This method can be called before the {\tt fec} object is created and
    is useful for allocating initial memory arrays.
\end{description}
%
Listed below is a simple example demonstrating the basic interface to
the {\tt fec} encoder/decoder object:
%
\input{listings/fec.example.c.tex}
%
For a more detailed example demonstrating the full capabilities of the
{\tt fec} object, see {\tt examples/fec\_example.c}.
%
%\subsection{encoder/decoder options}
%\label{module:fec:codecs}
Table~\ref{tab:fec:codecs} lists the available codecs and gives a brief
description for each.
All convolutional and Reed-Solomon codes are available only if {\tt libfec} is
installed \cite{libfec:web}.

% ------------ TABLE: FEC CODING SCHEMES ------------
\begin{table*}
\caption{Forward error-correction codecs available in \liquid}
\label{tab:fec:codecs}
\centering
{\small
\begin{tabular*}{0.75\textwidth}{l@{\extracolsep{\fill}}ll}
\toprule
{\it scheme} &
{\it asymptotic rate} &
{\it description}\\\otoprule
%
{\tt FEC\_UNKNOWN}              & -         & unknown/unsupported scheme\\
{\tt FEC\_NONE}                 & 1         & no error-correction\\
{\tt FEC\_REP3}                 & 1/3       & simple repeat code\\
{\tt FEC\_REP5}                 & 1/5       & simple repeat code\\
{\tt FEC\_HAMMING74}            & 4/7       & Hamming (7,4) block code\\
{\tt FEC\_HAMMING84}            & 1/2       & Hamming (7,4) with extra parity bit\\
{\tt FEC\_HAMMING128}           & 2/3       & Hamming (12,8) block code\\\midrule
%
% codecs not defined internally (see http://www.ka9q.net/code/fec/)
{\tt FEC\_CONV\_V27}            & 1/2       & $K=7$, $d_{free}=10$\\
{\tt FEC\_CONV\_V29}            & 1/2       & $K=9$, $d_{free}=12$\\
{\tt FEC\_CONV\_V39}            & 1/3       & $K=9$, $d_{free}=18$\\
{\tt FEC\_CONV\_V615}           & 1/6       & $K=15$, $d_{free}<=57$ (Heller 1968)\\\midrule
%
% punctured (perforated) codes
{\tt FEC\_CONV\_V27P23}         & 2/3       & $K=7$, $d_{free}=6$\\
{\tt FEC\_CONV\_V27P34}         & 3/4       & $K=7$, $d_{free}=5$\\
{\tt FEC\_CONV\_V27P45}         & 4/5       & $K=7$, $d_{free}=4$\\
{\tt FEC\_CONV\_V27P56}         & 5/6       & $K=7$, $d_{free}=4$\\
{\tt FEC\_CONV\_V27P67}         & 6/7       & $K=7$, $d_{free}=3$\\
{\tt FEC\_CONV\_V27P78}         & 7/8       & $K=7$, $d_{free}=3$\\\midrule
%
{\tt FEC\_CONV\_V29P23}         & 2/3       & $K=9$, $d_{free}=7$\\
{\tt FEC\_CONV\_V29P34}         & 3/4       & $K=9$, $d_{free}=6$\\
{\tt FEC\_CONV\_V29P45}         & 4/5       & $K=9$, $d_{free}=5$\\
{\tt FEC\_CONV\_V29P56}         & 5/6       & $K=9$, $d_{free}=5$\\
{\tt FEC\_CONV\_V29P67}         & 6/7       & $K=9$, $d_{free}=4$\\
{\tt FEC\_CONV\_V29P78}         & 7/8       & $K=9$, $d_{free}=4$\\\midrule
% 
% Reed-Solomon codes
{\tt FEC\_RS\_M8}               & 223/255   & Reed-Solomon block code, $m=8$\\\bottomrule


\end{tabular*}
}
\end{table*}%
% ------------------------


%-------------------- FIGURE: FEC BER (BUILT-IN) --------------------
\begin{figure}
\centering
\mbox{
  \subfigure[BER vs. $E_s/N_0$]
  {
    \includegraphics[trim = 3mm 2mm 0mm 2mm, clip, width=14cm]{figures.gen/fec_ber_esn0_hamming}
    \label{fig:fec:hamming_ber:esn0}
  }
} \quad
\mbox{
  \subfigure[BER vs. $E_b/N_0$]
  {
    \includegraphics[trim = 3mm 2mm 0mm 2mm, clip, width=14cm]{figures.gen/fec_ber_ebn0_hamming}
    \label{fig:fec:hamming_ber:ebn0}
  } \quad
}
% trim = left bottom right top
\caption{{\tt fec} bit error rates for built-in \liquid\ codecs}
\label{fig:fec:hamming_ber}
\end{figure}



%-------------------- FIGURE: FEC BER (CONVOLUTIONAL) --------------------
\begin{figure}
\centering
\mbox{
  \subfigure[BER vs. $E_s/N_0$]
  {
    \includegraphics[trim = 3mm 2mm 0mm 2mm, clip, width=14cm]{figures.gen/fec_ber_esn0_conv}
    \label{fig:fec:conv_ber:esn0}
  }
} \quad
\mbox{
  \subfigure[BER vs. $E_b/N_0$]
  {
    \includegraphics[trim = 3mm 2mm 0mm 2mm, clip, width=14cm]{figures.gen/fec_ber_ebn0_conv}
    \label{fig:fec:conv_ber:ebn0}
  } \quad
}
% trim = left bottom right top
\caption{{\tt fec} bit error rates for convolutional codes}
\label{fig:fec:conv_ber}
\end{figure}



%-------------------- FIGURE: FEC BER (CONVOLUTIONAL, PUNCTURED) --------------------
\begin{figure}
\centering
\mbox{
  \subfigure[BER vs. $E_s/N_0$]
  {
    \includegraphics[trim = 3mm 2mm 0mm 2mm, clip, width=14cm]{figures.gen/fec_ber_esn0_convpunc}
    \label{fig:fec:convpunc_ber:esn0}
  }
} \quad
\mbox{
  \subfigure[BER vs. $E_b/N_0$]
  {
    \includegraphics[trim = 3mm 2mm 0mm 2mm, clip, width=14cm]{figures.gen/fec_ber_ebn0_convpunc}
    \label{fig:fec:convpunc_ber:ebn0}
  } \quad
}
% trim = left bottom right top
\caption{{\tt fec} bit error rates for punctured convolutional codes}
\label{fig:fec:convpunc_ber}
\end{figure}



