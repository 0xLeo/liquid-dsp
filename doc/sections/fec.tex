% 
% MODULE : fec (forward error correction)
%

\section{fec (forward error correction)}
\label{module:fec}
%(basic), checksum, crc, Hamming block codes...
The fec module implements a set of forward error-correction codes for
ensuring and validating data integrity through a noisy channel.
Redudant (``parity'') bits are added to a data sequence to help correct for
errors introduced by the channel.

See also: {\tt packetizer}, {\tt interleaver}

\subsection{{\tt checksum}}
\label{module:fec:checksum}
A checksum is a simple way to validate data received through un-reliable means
(e.g. a noisy channel).
A checksum is, in essence, a weak error detection code that simply counts the
number of ones in a block of data (modulo 256).
The limitation, however, is that multiple bit errors might result in a false
positive validation of the corrupted data.
Here is a simple example:
%
\input{listings/checksum.example.c.tex}
%
For a much much stronger eror detection, use the cyclic redundancy check.

\subsection{{\tt crc32} (32-bit cyclic redundancy check)}
\label{module:fec:crc32}
This example demonstrates how a cyclic redundancy check (CRC) can be used to
validate data received through un-reliable means (e.g. a noisy channel).
A CRC is, in essence, a strong algebraic error detection code that computes a
key on a block of data using base-2 polynomials.
Here is a simple example:
%
\input{listings/crc32.example.c.tex}

\subsection{{\tt rep3} (simple repeat code)}
\label{module:fec:rep3}
The {\tt rep3} code is a simple repeat code which simply repeats the message
twice (transmits it three times).
The decoder takes a majority vote of the bits received by applying a simple
series bit masks.
If the original bit is represented as $s$, then the transmitted bits are
$s s s$.
Let the received bit sequence be $r_0 r_1 r_2$.
The estimated transmitted bit is {\tt 0} if the sum of the received bits is
less than 2, and {\tt 1} otherwise.
This is equivalent to
\[
    \hat{s} =   \Bigl(
                (r_0 \oplus r_1) + 
                (r_0 \oplus r_2) + 
                (r_1 \oplus r_2) 
                \Bigr)
                \oplus
                (r_1 \oplus r_1 \oplus r_2)
\]
where $\oplus$ represents logical {\it exclusive or} and $+$ represents
logical {\it or}.
In this fashion it is easy to decode several bytes of data at a time because
machine architectures have low-level bit-wise manipulation instructions which
can compute logical {\it exclusive or} and {\it or} very quickly.
This is precisely how \liquid\ decodes {\tt rep3} data, only in this case,
$s$, $r_0$, $r_1$, and $r_2$ represent a bytes of data rather than bits.
The above notation is useful because the quantity
$(r_0 \oplus r_1) + (r_0 \oplus r_2) + (r_1 \oplus r_2)$
represents the number of errors corrected.

It is well-known that repeat codes do not have strong error-correction
capabilities for their rate, are are located far from the Shannon capacity
bound \cite{Proakis:2001}.
However, their simplicity in implementation and computational complexity gains
them a place in digital communications, particularly in software radios where
spectral efficiency is secondary to computational complexity.

\subsection{Convolutional, Reed-Solomon codes}
\label{module:fec:conv}
\liquid\ takes advantage of convolutional and Reed-Solomon codes defined in
{\tt libfec} \cite{fec:web}.
These codes have much stronger error-correction capabilities than {\tt rep3}
and {\tt h74}, but are also much more computationally intensive to the host
processor.

\subsection{Interface}
\label{module:fec:interface}

\begin{description}
\item[{\tt fec\_create()}]
    creates a {\tt fec} object of a specific scheme.
\item[{\tt fec\_recreate()}]
    re-creates a {\tt fec} object with a different scheme.
\item[{\tt fec\_destroy()}]
    destroys a {\tt fec} object, freeing all internally-allocated memory
    arrays.
\item[{\tt fec\_encode()}]
    runs the error-correction encoder scheme on an input data array.
    The resulting encoded message is written to the output array, allocated by
    the user.
    To obtain the length of the output array necessary, use the
    {\tt fec\_get\_enc\_msg\_length()} method.
\item[{\tt fec\_decode()}]
    runs the error-correction decoder on an input data array.
    The resulting best-effort decoded message is written to the output array,
    allocated by the user.
    Depending upon the error-correction capabilities of the scheme, the
    resulting data might have been corrupted, and therefore it is recommended
    to use either a
    checksum (section~\ref{module:fec:checksum} or a
    cyclic redundancy check (section~\ref{module:fec:crc32})
    to validate data integrity.
\item[{\tt fec\_get\_enc\_msg\_length()}]
    returns the length of the encoded message in bytes.
    This method can be called before the {\tt fec} object is created and is
    useful for allocating initial memory arrays.
\end{description}

Here is a simple example demonstrating the basic interface to the {\tt fec}
encoder/decoder object:
\input{listings/fec.example.c.tex}

\subsection{encoder/decoder options}
\label{module:fec:codecs}
Table~\ref{tab:fec:codecs} lists the available codecs and gives a brief
description for each.
All convolutional and Reed-Solomon codes are available only if {\tt libfec} is
installed \cite{fec:web}.

% ------------ TABLE: MODULATION/CODING SCHEME PAIRS ------------
\begin{table*}
\caption{Forward error-correction codecs available in \liquid}
\label{tab:fec:codecs}
\centering
{\small
\begin{tabular*}{0.75\textwidth}{l@{\extracolsep{\fill}}ll}
\toprule
{\it scheme} &
{\it rate} &
{\it description}\\\otoprule
%
{\tt FEC\_UNKNOWN}              & -         & unknown/unsupported scheme\\
{\tt FEC\_NONE}                 & 1         & no error-correction\\
{\tt FEC\_REP3}                 & 1/3       & simple repeat code\\
{\tt FEC\_HAMMING74}            & 1/2       & Hamming (7,4) block code\\
{\tt FEC\_HAMMING84}            & 1/2       & Hamming (7,4) with extra parity bit\\\midrule
%
% codecs not defined internally (see http://www.ka9q.net/code/fec/)
{\tt FEC\_CONV\_V27}            & 1/2       & $K=7$, $d_{free}=10$\\
{\tt FEC\_CONV\_V29}            & 1/2       & $K=9$, $d_{free}=12$\\
{\tt FEC\_CONV\_V39}            & 1/3       & $K=9$, $d_{free}=18$\\
{\tt FEC\_CONV\_V615}           & 1/6       & $K=15$, $d_{free}<=57$ (Heller 1968)\\\midrule
%
% punctured (perforated) codes
{\tt FEC\_CONV\_V27P23}         & 2/3       & $K=7$, $d_{free}=6$\\
{\tt FEC\_CONV\_V27P34}         & 3/4       & $K=7$, $d_{free}=5$\\
{\tt FEC\_CONV\_V27P45}         & 4/5       & $K=7$, $d_{free}=4$\\
{\tt FEC\_CONV\_V27P56}         & 5/6       & $K=7$, $d_{free}=4$\\
{\tt FEC\_CONV\_V27P67}         & 6/7       & $K=7$, $d_{free}=3$\\
{\tt FEC\_CONV\_V27P78}         & 7/8       & $K=7$, $d_{free}=3$\\\midrule
%
{\tt FEC\_CONV\_V29P23}         & 2/3       & $K=9$, $d_{free}=7$\\
{\tt FEC\_CONV\_V29P34}         & 3/4       & $K=9$, $d_{free}=6$\\
{\tt FEC\_CONV\_V29P45}         & 4/5       & $K=9$, $d_{free}=5$\\
{\tt FEC\_CONV\_V29P56}         & 5/6       & $K=9$, $d_{free}=5$\\
{\tt FEC\_CONV\_V29P67}         & 6/7       & $K=9$, $d_{free}=4$\\
{\tt FEC\_CONV\_V29P78}         & 7/8       & $K=9$, $d_{free}=4$\\\midrule

% 
% Reed-Solomon codes
{\tt FEC\_RS\_M8}               & 223/255   & Reed-Solomon block code, $m=8$\\\bottomrule


\end{tabular*}
}
\end{table*}%
% ------------------------


