% 
% MODULE : fec (forward error correction)
%

\section{fec (forward error correction)}
\label{module:fec}
%(basic), checksum, crc, Hamming block codes...
The fec module implements a set of forward error-correction codes for
ensuring and validating data integrity through a noisy channel.
Redudant (``parity'') bits are added to a data sequence to help correct for
errors introduced by the channel.
The {\tt fec} object realizes forward error-correction capabilities in
\liquid\ while the methods {\tt checksum()} and {\tt crc32()} implement error
detection.
Certain FEC schemes are only available to \liquid\ by installing the external
{\tt libfec} library \cite{fec:web}, available as a free download.
A few low-rate (and low efficiency) codes are availble internally.

See also: {\tt packetizer}, {\tt interleaver}

\subsection{{\tt checksum}}
\label{module:fec:checksum}
A checksum is a simple way to validate data received through un-reliable means
(e.g. a noisy channel).
A checksum is, in essence, a weak error detection code that simply counts the
number of ones in a block of data (modulo 256).
The limitation, however, is that multiple bit errors might result in a false
positive validation of the corrupted data.
Here is a simple example:
%
\input{listings/checksum.example.c.tex}
%
It is important to realize that a checksum does not correct any errors, but
can only detect their presence.
For a much much stronger error detection, use the cyclic redundancy check.

\subsection{{\tt crc32} (32-bit cyclic redundancy check)}
\label{module:fec:crc32}
This example demonstrates how a cyclic redundancy check (CRC) can be used to
validate data received through un-reliable means (e.g. a noisy channel).
A CRC is, in essence, a strong algebraic error detection code that computes a
key on a block of data using base-2 polynomials.
While it is a strong error-detection method, a CRC is not an error-correction
code.
Here is a simple example:
%
\input{listings/crc32.example.c.tex}

\subsection{{\tt rep3}, {\tt rep5} (simple repeat codes)}
\label{module:fec:rep}
The {\tt rep3} code is a simple repeat code which simply repeats the message
twice (transmits it three times).
The decoder takes a majority vote of the bits received by applying a simple
series bit masks.
If the original bit is represented as $s$, then the transmitted bits are
$s s s$.
Let the received bit sequence be $r_0 r_1 r_2$.
The estimated transmitted bit is {\tt 0} if the sum of the received bits is
less than 2, and {\tt 1} otherwise.
This is equivalent to
\[
    \hat{s} =   (r_0 \land r_1) + 
                (r_0 \land r_2) + 
                (r_1 \land r_2) 
\]
where $+$ represents logical {\it or} and $\land$ represents
logical {\it and}.
An error is detected if
\[
    \hat{e} =   (r_0 \oplus r_1) + 
                (r_0 \oplus r_2) + 
                (r_1 \oplus r_2) 
\]
where $\oplus$ represents logical {\it exclusive or}.
In this fashion it is easy to decode several bytes of data at a time because
machine architectures have low-level bit-wise manipulation instructions which
can compute logical {\it exclusive or} and {\it or} very quickly.
This is precisely how \liquid\ decodes {\tt rep3} data, only in this case,
$s$, $r_0$, $r_1$, and $r_2$ represent a bytes of data rather than bits.

The {\tt rep5} code operates similarly, except that it transmits five copies
of the original data sequence, rather than just three.
The decoder takes the five received bits $r_0,\ldots,r_4$ and adds (modulo
2) the logical {\it and} of every combination of three bits, viz.
\[
    \hat{s} = \sum_{i\ne j \ne k} {(r_i \land r_j \land r_k)}
\]
This roughly doubles the number of clock cycles to decode over {\tt rep3}.

It is well-known that repeat codes do not have strong error-correction
capabilities for their rate, are are located far from the Shannon capacity
bound \cite{Proakis:2001}.
They are exceptionally weak relative to convolutional Viterbi and Reed-Solomon
codes.
However, their simplicity in implementation and low computational complexity
gains them a place in digital communications, particularly in software radios
where spectral efficiency goals might be secondary to processing contraints.

\subsection{Convolutional, Reed-Solomon codes}
\label{module:fec:conv}
\liquid\ takes advantage of convolutional and Reed-Solomon codes defined in
{\tt libfec} \cite{fec:web}.
These codes have much stronger error-correction capabilities than {\tt rep3},
{\tt rep5}, {\tt h74}, and {\tt h84}, but are also much more computationally
intensive to the host processor.

\subsection{Interface}
\label{module:fec:interface}
In designing the {\tt fec} interface, we have tried to keep simplicity and
reconfigurability in mind.
%The goal is to allow flexibility in the allocation ...
%TODO finish interface description

\begin{description}
\item[{\tt fec\_create()}]
    creates a {\tt fec} object of a specific scheme.
    Notice that the length of the input message does not need to be specified
    until {\tt encode()} or {\tt decode()} is invoked.
\item[{\tt fec\_recreate()}]
    recreates an existing {\tt fec} object with a different scheme.
\item[{\tt fec\_destroy()}]
    destroys a {\tt fec} object, freeing all internally-allocated memory
    arrays.
\item[{\tt fec\_encode()}]
    runs the error-correction encoder scheme on an input data array.
    The resulting encoded message is written to the output array, allocated by
    the user.
    The first argument is the {\tt fec} object pointer, instantiated with the
    {\tt create()} method.
    The second argument is an integer representing the size of the decoded
    message in bytes.
    The third and fourth arguments are the externally allocated input message
    and the resulting output message, respectively.
    To obtain the length of the output array necessary, use the
    {\tt fec\_get\_enc\_msg\_length()} method.
\item[{\tt fec\_decode()}]
    runs the error-correction decoder on an input data array.
    The resulting best-effort decoded message is written to the output array,
    allocated by the user.
    Depending upon the error-correction capabilities of the scheme, the
    resulting data might have been corrupted, and therefore it is recommended
    to use either a
    checksum (section~\ref{module:fec:checksum} or a
    cyclic redundancy check (section~\ref{module:fec:crc32})
    to validate data integrity.
\item[{\tt fec\_get\_enc\_msg\_length()}]
    returns the length of the encoded message in bytes.
    This method can be called before the {\tt fec} object is created and is
    useful for allocating initial memory arrays.
\end{description}

Here is a simple example demonstrating the basic interface to the {\tt fec}
encoder/decoder object:
\input{listings/fec.example.c.tex}
For a more detailed example demonstrating the full capabilities of the
{\tt fec} object, see {\tt examples/fec\_example.c}.

%\subsection{encoder/decoder options}
%\label{module:fec:codecs}
Table~\ref{tab:fec:codecs} lists the available codecs and gives a brief
description for each.
All convolutional and Reed-Solomon codes are available only if {\tt libfec} is
installed \cite{fec:web}.

% ------------ TABLE: MODULATION/CODING SCHEME PAIRS ------------
\begin{table*}
\caption{Forward error-correction codecs available in \liquid}
\label{tab:fec:codecs}
\centering
{\small
\begin{tabular*}{0.75\textwidth}{l@{\extracolsep{\fill}}ll}
\toprule
{\it scheme} &
{\it rate} &
{\it description}\\\otoprule
%
{\tt FEC\_UNKNOWN}              & -         & unknown/unsupported scheme\\
{\tt FEC\_NONE}                 & 1         & no error-correction\\
{\tt FEC\_REP3}                 & 1/3       & simple repeat code\\
{\tt FEC\_REP5}                 & 1/5       & simple repeat code\\
{\tt FEC\_HAMMING74}            & 1/2       & Hamming (7,4) block code\\
{\tt FEC\_HAMMING84}            & 1/2       & Hamming (7,4) with extra parity bit\\\midrule
%
% codecs not defined internally (see http://www.ka9q.net/code/fec/)
{\tt FEC\_CONV\_V27}            & 1/2       & $K=7$, $d_{free}=10$\\
{\tt FEC\_CONV\_V29}            & 1/2       & $K=9$, $d_{free}=12$\\
{\tt FEC\_CONV\_V39}            & 1/3       & $K=9$, $d_{free}=18$\\
{\tt FEC\_CONV\_V615}           & 1/6       & $K=15$, $d_{free}<=57$ (Heller 1968)\\\midrule
%
% punctured (perforated) codes
{\tt FEC\_CONV\_V27P23}         & 2/3       & $K=7$, $d_{free}=6$\\
{\tt FEC\_CONV\_V27P34}         & 3/4       & $K=7$, $d_{free}=5$\\
{\tt FEC\_CONV\_V27P45}         & 4/5       & $K=7$, $d_{free}=4$\\
{\tt FEC\_CONV\_V27P56}         & 5/6       & $K=7$, $d_{free}=4$\\
{\tt FEC\_CONV\_V27P67}         & 6/7       & $K=7$, $d_{free}=3$\\
{\tt FEC\_CONV\_V27P78}         & 7/8       & $K=7$, $d_{free}=3$\\\midrule
%
{\tt FEC\_CONV\_V29P23}         & 2/3       & $K=9$, $d_{free}=7$\\
{\tt FEC\_CONV\_V29P34}         & 3/4       & $K=9$, $d_{free}=6$\\
{\tt FEC\_CONV\_V29P45}         & 4/5       & $K=9$, $d_{free}=5$\\
{\tt FEC\_CONV\_V29P56}         & 5/6       & $K=9$, $d_{free}=5$\\
{\tt FEC\_CONV\_V29P67}         & 6/7       & $K=9$, $d_{free}=4$\\
{\tt FEC\_CONV\_V29P78}         & 7/8       & $K=9$, $d_{free}=4$\\\midrule
% 
% Reed-Solomon codes
{\tt FEC\_RS\_M8}               & 223/255   & Reed-Solomon block code, $m=8$\\\bottomrule


\end{tabular*}
}
\end{table*}%
% ------------------------


