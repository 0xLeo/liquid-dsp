% 
% MODULE : fec (forward error correction)
%

\section{fec (forward error correction)}
\label{module:fec}
%(basic), checksum, crc, Hamming block codes...
The fec module implements a set of forward error-correction codes for
ensuring and validating data integrity through a noisy channel.
Redudant (``parity'') bits are added to a data sequence to help correct for
errors introduced by the channel.

See also: {\tt packetizer}, {\tt interleaver}

\subsection{Interface}
\label{module:fec:interface}

\begin{description}
\item[{\tt fec\_create()}]
\item[{\tt fec\_destroy()}]
\item[{\tt fec\_encode()}]
\item[{\tt fec\_decode()}]
\end{description}


\subsection{{\tt checksum}}
\label{module:fec:checksum}
A checksum is a simple way to validate data received through un-reliable means
(e.g. a noisy channel).
A checksum is, in essence, a weak error detection code that simply counts the
number of ones in a block of data (modulo 256).
The limitation, however, is that multiple bit errors might result in a false
positive validation of the corrupted data.
Here is a simple example:
%
\input{listings/checksum.example.c.tex}
%
For a much much stronger eror detection, use the cyclic redundancy check.

\subsection{{\tt crc32} (32-bit cyclic redundancy check)}
\label{module:fec:crc32}
This example demonstrates how a cyclic redundancy check (CRC) can be used to
validate data received through un-reliable means (e.g. a noisy channel).
A CRC is, in essence, a strong algebraic error detection code that computes a
key on a block of data using base-2 polynomials.
Here is a simple example:
%
\input{listings/crc32.example.c.tex}

\subsection{{\tt rep3} (simple repeat code)}
\label{module:fec:rep3}
The {\tt rep3} code is a simple repeat code which simply repeats the message
twice (transmits it three times).
The decoder takes a majority vote of the bits received by applying a simple
series bit masks.
If the original bit is represented as $s$, then the transmitted bits are
$s s s$.
Let the received bit sequence be $r_0 r_1 r_2$.
The estimated transmitted bit is {\tt 0} if the sum of the received bits is
less than 2, and {\tt 1} otherwise.
This is equivalent to
\[
    \hat{s} =   \Bigl(
                (r_0 \oplus r_1) + 
                (r_0 \oplus r_2) + 
                (r_1 \oplus r_2) 
                \Bigr)
                \oplus
                (r_1 \oplus r_1 \oplus r_2)
\]
where $\oplus$ represents logical {\it exclusive or} and $+$ represents
logical {\it or}.
In this fashion it is easy to decode several bytes of data at a time because
machine architectures have low-level bit-wise manipulation instructions which
can compute logical {\it exclusive or} and {\it or} very quickly.
This is precisely how \liquid\ decodes {\tt rep3} data, only in this case,
$s$, $r_0$, $r_1$, and $r_2$ represent a bytes of data rather than bits.
The above notation is useful because the quantity
$(r_0 \oplus r_1) + (r_0 \oplus r_2) + (r_1 \oplus r_2)$
represents the number of errors corrected.

It is well-known that repeat codes do not have strong error-correction
capabilities for their rate, are are located far from the Shannon capacity
bound \cite{Proakis:2001}.
However, their simplicity in implementation and computational complexity gains
them a place in digital communications, particularly in software radios where
spectral efficiency is secondary to computational complexity.

\subsection{{\tt h74} (Hamming (7,4) code)}
\label{module:fec:h74}

\subsection{{\tt v27} (rate $1/2$, $K=7$ convolutional code)}
\label{module:fec:v27}

\subsection{{\tt v29} (rate $1/2$, $K=9$ convolutional code)}
\label{module:fec:v29}

\subsection{{\tt v39} (rate $1/3$, $K=9$ convolutional code)}
\label{module:fec:v39}

\subsection{{\tt v615} (rate $1/6$, $K=15$ convolutional code)}
\label{module:fec:v615}

\subsection{{\tt rs8} (Reed-Solomon code)}
\label{module:fec:rs8}

\subsection{punctured codes}
\label{module:fec:punctured}

