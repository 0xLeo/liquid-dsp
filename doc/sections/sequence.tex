% 
% MODULE : sequence
%

\section{sequence}
\label{module:sequence}
linear feedback shift registers, complementary codes, etc.

\subsection{{\tt bsequence}, generic binary sequence}
\label{module:sequence:bsequence}
...
This is particularly useful in wireless communications for correlating long
bit sequences in seeking frame preambles and packet headers.
%This is also useful in the physical layer description 
The {\tt bsequence} object internally stores its sequence of bits as an array
of bytes which handles shifting values even faster than the {\tt window}
family of objects.

\begin{description}
\item[{\tt bsequence\_create(num\_bits)}]
    creates a {\tt bsequence} object of length {\tt num\_bits}, filled
    initially with zeros.
\item[{\tt bsequence\_destroy()}]
    destroys the object, freeing all internally-allocated memory.
\item[{\tt bsequence\_clear()}]
    resets the sequence to all zeros.
\item[{\tt bsequence\_init()}]
    initializes the sequence on an external array.
\item[{\tt bsequence\_print()}]
    prints the contents of the sequence to the screen.
\item[{\tt bsequence\_push()}]
    pushes a bit into the back (right side) of a binary sequence, and in turn
    drops the left-most bit.
    Only the right-most (least-significant) bit of the input is regarded.
    For example, pushing a {\tt 1} into the sequence {\tt 0010011} results in
    {\tt 0100111}.
\item[{\tt bsequence\_circshift()}]
    circularly shifts a binary sequence left, pushing the left-most bit back
    into the right-most position.
    For example, invoking a circular shift on the sequence {\tt 1001110}
    results in {\tt 0011101}.
\item[{\tt bsequence\_correlate()}]
    runs a binary correlation of two {\tt bsequence} objects, and returns the
    number of similar bits in both sequences.
    For example, correlating the sequence {\tt 11110000} with {\tt 11001100}
    yields {\tt 4}.
\item[{\tt bsequence\_add()}]
    computes the binary addition of two sequences.
    Binary addition of two bits is equivalent to their logical
    {\em exclusive or}, $\oplus$.
    For example, the binary addition of
    {\tt 01100011} and
    {\tt 11011001} is
    {\tt 10111010}.
\item[{\tt bsequence\_mul()}]
    computes the binary multiplication of two sequences.
    Binary multiplication of two bits is equivalent to their logical
    {\em and}, $\land$.
    For example, the binary multiplication of
    {\tt 01100011} and
    {\tt 11011001} is
    {\tt 01000001}.
\item[{\tt bsequence\_accumulate()}]
    accumulates the {\tt 1}s in a binary sequence
\item[{\tt bsequence\_get\_length()}]
    returns the length of the sequence (number of bits)
\item[{\tt bsequence\_index()}]
    returns the bit at a particular index of the sequence, starting from the
    right-most bit.
    For example, indexing the sequence {\tt 00000001} at index {\tt 0} gives
    the value {\tt 1}.
\end{description}


\subsection{{\tt msequence}, $m$-sequence (linear feedback shift register)}
\label{module:sequence:msequence}
The {\tt msequence} object in \liquid\ is really just a linear feedback shift
register (LFSR), efficiently implemented using unsigned integers.
The LFSR consists of an $m$-bit shift register, $v$, and generator polynomial
$g$.
For primitive polynomials, the output sequence has a length $n=2^m-1$ before
repeating.
This sequence is known as a maximal-length P/N (positive/negative) sequence,
and consists of several useful properties:
\begin{enumerate}
\item the output sequence has very good auto-correlation properties; when
      aligned, the sequence, of course, correlates perfectly to 1.
      When misaligned by any amount, however, the sequence correlates to
      exactly $-1/n$.
\item the sequence is easily generated using a linear feedback shift register
\end{enumerate}

Here is a brief description of the {\tt msequence} oject's interface in
\liquid:
\begin{description}
\item[{\tt msequence\_create(\_m)}]
    creates an {\tt msequence} object with an internal shift register length
    of {\tt \_m} bits.
    The sequence is automatically initialized to the default sequence of that
    length, e.g. {\tt LIQUID\_MSEQUENCE\_N511}, and the initial state is set
    to {\tt 000...001}.
\item[{\tt msequence\_destroy()}]
    destroys the object, freeing all internal memory.
\item[{\tt msequence\_init()}]
    initializes the {\tt msequence} generator object {\tt \_ms} where
    $m$ is the generator polynomial length (number of bits),
    $g$ is the generator polynomial, and
    $a$ is the initial state of the internal shift register (initially
    {\tt  1}).
\item[{\tt msequence\_print()}]
    prints the contents of the sequence to the screen.
\item[{\tt msequence\_advance()}]
    advances the {\tt msequence} object's shift register by computing the
    binary dot product of the register with the generator polynomial.
    The resulting bit is sum of {\tt 1}s modulo 2 of the dot product and is
    fed back into the end of the shift register, as well as returned to the
    user.
\item[{\tt msequence\_generate\_symbol()}]
    generates a pseudo-random {\tt \_bps}-bit symbol from the shift register.
    This is accomplished by advancing the {\tt msequence} object {\tt \_bps}
    times and shifting the result back into the symbol.
    It is important to note that because the sequence repeats every $n$ bits,
    if the random number is an even multiple of $n$, the random sequence will
    repeat every {\tt \_bps} symbols.
    For example, if $m=4$ ($n=15$) and {\tt \_bps} is 3, then the sequence
    will repeat 5 times.
\item[{\tt msequence\_reset()}]
    resets the {\tt msequence} object's internal shift register to the
    original state (typically {\tt 000...001}).
\item[{\tt msequence\_get\_length()}]
    returns the length of the sequence, $n$
\item[{\tt msequence\_get\_state()}]
    returns the internal state of the sequence, $v$
\end{description}

The auto-correlation of the $m$-sequence with generator polynomial
$g=${\tt 1000011}
can be seen in Figure~\ref{fig:module:sequence:msequence}.
The shift register has six bits ($m=6$) and therefore the output sequence is
of length $n=2^m-1=63$.
Notice that the autocorrelation is equal to unity with no delay, and nearly
zero ($-1/63$) for all other delays.

% FIGURE: msequence autocorrelation
\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/sequence_msequence}
\caption{{\tt msequence} autocorrelation, $m=6$ ($n=63$), $g=${\tt 1000011}}
\label{fig:module:sequence:msequence}
\end{figure}

%\cite{Peterson:1995}

% ------------ TABLE: M-SEQUENCE GENERATOR POLYNOMIALS ------------
\begin{table*}
\caption{Default $m$-sequence generator polynomials in \liquid}
\label{tab:sequence:genpoly}
\centering
{\small
\begin{tabular*}{0.75\textwidth}{l@{\extracolsep{\fill}}lllr}
\toprule
$m$ &
$n$ &
$g$ (hex) &
$g$ (octal) &
$g$ (binary)\\\otoprule
    2   & 3     & {\tt 0x0007}  & {\tt 000007}  & {\tt           111} \\
    3   & 7     & {\tt 0x000b}  & {\tt 000013}  & {\tt          1011} \\
    4   & 15    & {\tt 0x0013}  & {\tt 000023}  & {\tt         10011} \\
    5   & 31    & {\tt 0x0025}  & {\tt 000045}  & {\tt        100101} \\
    6   & 63    & {\tt 0x0043}  & {\tt 000103}  & {\tt       1000011} \\
    7   & 127   & {\tt 0x0089}  & {\tt 000211}  & {\tt      10001001} \\
    8   & 255   & {\tt 0x012d}  & {\tt 000455}  & {\tt     100101101} \\
    9   & 511   & {\tt 0x0211}  & {\tt 001021}  & {\tt    1000010001} \\
    10  & 1023  & {\tt 0x0409}  & {\tt 002011}  & {\tt   10000001001} \\
    11  & 2047  & {\tt 0x0805}  & {\tt 004005}  & {\tt  100000000101} \\
    12  & 4095  & {\tt 0x1053}  & {\tt 010123}  & {\tt 1000001010011} \\\bottomrule
\end{tabular*}
}
\end{table*}%
% ------------------------




\subsection{complementary codes}
\label{module:sequence:ccodes}


